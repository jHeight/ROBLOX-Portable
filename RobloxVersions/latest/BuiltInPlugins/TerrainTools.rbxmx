<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Model" referent="RBX9187B8A60A884900BD79BADE081A5023">
		<Properties>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Terrain Tools</string>
			<Ref name="PrimaryPart">null</Ref>
		</Properties>
		<Item class="Script" referent="RBXA73176EE5C6248B9AE13D1CC7FFD398E">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">TerrainBrushScript</string>
				<ProtectedString name="Source"><![CDATA[--Made by Stickmasterluke




while not workspace:WaitForChild('Terrain').IsSmooth do
	workspace.Terrain.Changed:wait()
end

local on = false
local setup = false
local currentTool = 'Create'


--[[
	How to add a module:
		1. Add the require to the modules table below.
		2. Add a plugin button for it into the pluginButtons table, with the same index as used in the modules table.
		3. You win.

	How modules work
		Your ModuleScript should return a table. The table can contain the following functions
			On	= This function will be called when your tool is selected. Will hand in the mouse object, and a Deselect function to turn it off.
			Off	= This function will be called when your tool is deselected.
			operation = This function will be called when this toolset's brushing functionality is used
				operation(centerPoint, materialsTable, occupanciesTable, resolution, selectionSize, strength, desiredMaterial, brushShape, minBounds, maxBounds)
]]

local modules = {
	['Smooth'] = require(script.Parent.SmootherModule),
	['Generate'] = require(script.Parent.GenerationModule),
	['Region Editor'] = require(script.Parent.RegionEditorModule),
}


local toolBar = plugin:CreateToolbar('Smooth Terrain')

local pluginButtons = {
	['Generate'] = toolBar:CreateButton(
		'Generate',
		'Generate landscapes of terrain.',	--hover text
		'http://www.roblox.com/asset/?id=236006872'--232378322'--225329851'	--icon
	),
	['Add'] = toolBar:CreateButton(
		'Add',	--button title
		'Click and hold to add terrain.',
		'http://www.roblox.com/asset/?id=225328572'--232377864'--225328572'
	),
	['Subtract'] = toolBar:CreateButton(
		'Subtract',
		'Click and hold to remove terrain.',
		'http://www.roblox.com/asset/?id=225328818'
	),
	['Paint'] = toolBar:CreateButton(
		'Paint',
		'Paint the material of the terrain.',
		'http://www.roblox.com/asset/?id=225328954'
	),
	['Grow'] = toolBar:CreateButton(
		'Grow',
		'Click and hold to grow and expand terrain.',
		'http://www.roblox.com/asset/?id=225329153'
	),
	['Erode'] = toolBar:CreateButton(
		'Erode',
		'Click and hold to erode and remove terrain.',
		'http://www.roblox.com/asset/?id=225329301'
	),
	['Smooth'] = toolBar:CreateButton(
		'Smooth',
		'Brush to smooth out rough or jagged terrain.',
		'http://www.roblox.com/asset/?id=225329641'
	),
	['Region Editor'] = toolBar:CreateButton(
		'Regions',
		'Manipulate regions of smooth terrain.',
		'http://www.roblox.com/asset/?id=240631063'
	),
}

for name, button in pairs(pluginButtons) do
	button.Click:connect(function()
		if not on or (currentTool ~= nil and name ~= currentTool) then	--if off or on but current tool isn't the desired tool, then select this tool.
			if not setup then	--I do this so that things only get set up when this plugin is used.
				FirstTimeSetUp()
			end
			Selected(button, name)
		else
			Deselected()
		end
	end)
end

function FirstTimeSetUp()
	setup = true
	local changeHistory = game:GetService('ChangeHistoryService')
	local terrain = game.Workspace.Terrain
	local coreGui = game:GetService('CoreGui')
	local gui = script.Parent:WaitForChild('TerrainBrushGui')
	local guiFrame = gui:WaitForChild('Frame')
	local closeButton = guiFrame:WaitForChild('CloseButton')
	local checkBox1 = guiFrame:WaitForChild('CheckBox1')
	local checkBox2 = guiFrame:WaitForChild('CheckBox2')
	local checkBox3 = guiFrame:WaitForChild('CheckBox3')
	local toolTip1 = guiFrame:WaitForChild('ToolTip1')
	local toolTip2 = guiFrame:WaitForChild('ToolTip2')
	local library = assert(LoadLibrary('RbxGui'))
	local mouse = plugin:GetMouse()
	local userInput = game:GetService('UserInputService')

	----SETTINGS----
	local selectionSize = 6
	local strength = .5
	local snapToGrid = false
	local planeLock = false
	local brushShape = 'Sphere'
	local materialSelection = 'Grass'
	local dynamicMaterial = false
	----------------
	--SUB SETTINGS--
	local resolution = 4			--This is the size of voxels on Roblox. Why is this a variable? ;)
	local minSelectionSize = 1
	local maxSelectionSize = 16
	local materialSelections = {'Grass', 'Sand', 'Rock', 'Slate', 'Water', 'Wood Planks', 'Brick', 'Concrete'}	--display order
	local clickThreshold = .1
	local toolTipShowTime = 3.5
	----------------

	--Variables--
	local brushShapes = {
		['Sphere'] = {
			name = 'Sphere',
			button = guiFrame:WaitForChild('ShapeButton1'),
			image = 'http://www.roblox.com/asset/?id=225799533',
			selectedImage = 'http://www.roblox.com/asset/?id=225801914',
		},
		['Box'] = {
			name = 'Box',
			button = guiFrame:WaitForChild('ShapeButton2'),
			image = 'http://www.roblox.com/asset/?id=225799696',
			selectedImage = 'http://www.roblox.com/asset/?id=225802254',
		},
	}
	local materialDictionary = {
		['Grass'] = Enum.Material.Grass,
		['Concrete'] = Enum.Material.Concrete,
		['Rock'] = Enum.Material.Rock,
		['Slate'] = Enum.Material.Slate,
		['Brick'] = Enum.Material.Brick,
		['Water'] = Enum.Material.Water,
		['Sand'] = Enum.Material.Sand,
		['Wood Planks'] = Enum.Material.WoodPlanks,
		['Dynamic'] = Enum.Material.Grass,
	}
	local materialImageDictionary = {
		['Grass'] = 'http://www.roblox.com/asset/?id=225314676',
		['Concrete'] = 'http://www.roblox.com/asset/?id=225314983',
		['Rock'] = 'http://www.roblox.com/asset/?id=225315178',
		['Slate'] = 'http://www.roblox.com/asset/?id=225315290',
		['Brick'] = 'http://www.roblox.com/asset/?id=225315419',
		['Water'] = 'http://www.roblox.com/asset/?id=225315529',
		['Sand'] = 'http://www.roblox.com/asset/?id=225315607',
		['Wood Planks'] = 'http://www.roblox.com/asset/?id=225315705',
		--['Dynamic'] = 'http://www.roblox.com/asset/?id=220983525',
	}
	local forcePlaneLock = false
	local forceSnapToGrid = false
	local forceDynamicMaterial = false
	local forceDynamicMaterialTo = true
	local forceMaterial = nil
	local selectionPart = nil
	local selectionObject = nil
	local gridLineParts = {}
	local currentLoopTag = nil
	local lastMainPoint = Vector3.new(0, 0, 0)
	local click = false
	local firstOperation = tick()
	local downKeys = {}
	local lastPlanePoint = Vector3.new(0, 0, 0)
	local lastNormal = Vector3.new(0, 1, 0)
	local lastCursorDistance = 300
	local toolTip1Change = nil
	local toolTip2Change = nil
	local materialAir = Enum.Material.Air
	local materialWater = Enum.Material.Water
	local ceil = math.ceil
	local floor = math.floor
	local abs = math.abs
	local min = math.min
	local max = math.max
	local sqrt = math.sqrt
	local sin = math.sin
	local cos = math.cos
	local pi = math.pi
	-------------


	--Gui Setup--
	local selectionSizeSlider, selectionSizeValue = library.CreateSlider(maxSelectionSize, 90, UDim2.new(1, -98, 0, 40))
	selectionSizeSlider.Parent = guiFrame
	selectionSizeValue.Changed:connect(function()
		selectionSize = selectionSizeValue.Value
		if selectionPart then
			selectionPart.Size = Vector3.new(1, 1, 1) * selectionSize * resolution + Vector3.new(.1, .1, .1)
		end

		toolTip1.Visible = true
		local currentToolTip1Change = {}
		toolTip1Change = currentToolTip1Change
		wait(toolTipShowTime)
		if toolTip1Change == currentToolTip1Change then
			toolTip1.Visible = false
		end
	end)
	selectionSizeValue.Value = selectionSize
	toolTip1.Visible = false


	local strengthslider, strengthValue = library.CreateSlider(101, 90, UDim2.new(1, -98, 0, 65))
	strengthslider.Parent = guiFrame
	strengthValue.Changed:connect(function()
		strength = (strengthValue.Value - 1) / 100
		if selectionObject then
			selectionObject.SurfaceTransparency = .95 - strength * .3
		end

		toolTip2.Visible = true
		local currentToolTip2Change = {}
		toolTip2Change = currentToolTip2Change
		wait(toolTipShowTime)
		if toolTip2Change == currentToolTip2Change then
			toolTip2.Visible = false
		end
	end)
	strengthValue.Value = strength * 100
	toolTip2.Visible = false


	function setBrushShape(newBrushShape)
		brushShape = newBrushShape
		for _,v in pairs(brushShapes) do
			--v.button.Image = (newBrushShape == v) and v.selectedImage or v.image
			v.button.ImageTransparency = (newBrushShape == v.name) and 0 or .5
			v.button.ImageColor3 = (newBrushShape == v.name) and Color3.new(1,1,1) or Color3.new(.5,.5,.5)
		end
		clearSelection()
	end
	for _,v in pairs(brushShapes) do
		v.button.MouseButton1Down:connect(function()
			setBrushShape(v.name)
		end)
	end

	local function setMaterialSelection(newMaterialSelection)
		materialSelection = newMaterialSelection
		forceSnapToGrid = materialSelection == 'Brick' or materialSelection == 'Wood Planks'
		updateSnapToGrid()
		for _, v in pairs(guiFrame:GetChildren()) do
			if string.sub(v.Name,1,14) == 'MaterialButton' then
				if string.sub(v.Name,15) == newMaterialSelection then
					v.BackgroundTransparency = .1
				else
					v.BackgroundTransparency = 1
				end
			end
		end
	end
	for i, materialName in pairs(materialSelections) do
		local newMaterialButton = Instance.new('ImageButton')
		newMaterialButton.Name = 'MaterialButton' .. materialName
		newMaterialButton.BorderSizePixel = 2
		newMaterialButton.BorderColor3 = Color3.new(.2, 1, 1)
		newMaterialButton.BackgroundColor3 = Color3.new(.2, 1, 1)
		newMaterialButton.BackgroundTransparency = 1
		newMaterialButton.Image = materialImageDictionary[materialName]
		newMaterialButton.Size = UDim2.new(0, 35, 0, 35)
		newMaterialButton.Position = UDim2.new(0, 5 + ((i-1) % 4) * 40, 0, 195 + ceil(i/4) * 40)
		newMaterialButton.MouseButton1Down:connect(function()
			setMaterialSelection(materialName)
		end)
		newMaterialButton.Parent = guiFrame
	end
	

	function updatePlaneLock()
		checkBox1.Style = forcePlaneLock and Enum.ButtonStyle.RobloxRoundButton or Enum.ButtonStyle.RobloxRoundDefaultButton
		checkBox1.Text = (planeLock or forcePlaneLock) and 'X' or ''
		checkBox1.AutoButtonColor = not forcePlaneLock
		if not (planeLock or forcePlaneLock) then
			clearGrid()
		end
	end
	checkBox1.MouseButton1Down:connect(function()
		planeLock = not planeLock
		updatePlaneLock()
	end)

	function updateSnapToGrid()
		checkBox2.Style = forceSnapToGrid and Enum.ButtonStyle.RobloxRoundButton or Enum.ButtonStyle.RobloxRoundDefaultButton
		checkBox2.Text = (snapToGrid or forceSnapToGrid) and 'X' or ''
		checkBox2.AutoButtonColor = not forceSnapToGrid
	end
	checkBox2.MouseButton1Down:connect(function()
		snapToGrid = not snapToGrid
		updateSnapToGrid()
	end)

	function updateDynamicMaterial()
		local isDynamic = dynamicMaterial
		if forceDynamicMaterial then
			isDynamic = forceDynamicMaterialTo
		end
		checkBox3.Style = forceDynamicMaterial and Enum.ButtonStyle.RobloxRoundButton or Enum.ButtonStyle.RobloxRoundDefaultButton
		checkBox3.AutoButtonColor = not forceDynamicMaterial
		checkBox3.Text =  isDynamic and 'X' or ''
		local desiredSize = UDim2.new(0, 180, 0, 245)
		if not isDynamic then
			desiredSize = desiredSize + UDim2.new(0, 0, 0, 5 + ceil(#materialSelections / 4) * 40)	--Dynamically resizes frame if we add more materials later.
		end
		--guiFrame:TweenSize(desiredSize, 'Out', 'Quad', .5)	--illegal in studio
		guiFrame.Size = desiredSize
		for _, v in pairs(guiFrame:GetChildren()) do
			if string.sub(v.Name,1,14) == 'MaterialButton' then
				v.Visible = not isDynamic
			end
		end
	end
	checkBox3.MouseButton1Down:connect(function()
		dynamicMaterial = not dynamicMaterial
		updateDynamicMaterial()
	end)
	-------------


	do
		local runService = game:GetService('RunService').RenderStepped
		function quickWait(waitTime)
			if not waitTime then
				runService:wait()
			elseif waitTime < .033333 then
				local startTick = tick()
				runService:wait()
				local delta = tick() - startTick
				if delta <= waitTime * .5 then
					quickWait(waitTime - delta)
				end
			else
				wait(waitTime)
			end
		end
	end

	function clearSelection()
		if selectionObject then
			selectionObject:Destroy()
			selectionObject = nil
		end
		if selectionPart then
			selectionPart:Destroy()
			selectionPart = nil
		end
	end

	function clearGrid()
		for i, v in pairs(gridLineParts) do
			if v then
				v:Destroy()
			end
			gridLineParts[i] = nil
		end
	end

	function drawGrid(point, normal, transparency, color)
		local transparency = transparency or .95
		local color = BrickColor.new(color or 'Institutional white')--'Pastel light blue')
		local gridCellSize = selectionSize * resolution
		local gridSize = 10
		local baseCframe = CFrame.new(point, point + normal)
		local normalSpase = CFrame.new(Vector3.new(0, 0, 0), normal):pointToObjectSpace(point)
		local roundedNormalOffset = (Vector3.new((normalSpase.x / gridCellSize) % 1, (normalSpase.y / gridCellSize) % 1, 0) - Vector3.new(.5, .5, 0)) * -gridCellSize
		for u = 1, gridSize do
			local linePart = gridLineParts[u]
			if not linePart then
				linePart = Instance.new('Part')
				linePart.Transparency = 1
				linePart.TopSurface = 'Smooth'
				linePart.BottomSurface = 'Smooth'
				linePart.Anchored = true
				linePart.CanCollide = false
				linePart.formFactor = 'Custom'
				local selectionBox = Instance.new('SelectionBox')
				selectionBox.Color = color
				selectionBox.Transparency = transparency
				selectionBox.Adornee = linePart
				selectionBox.Parent = linePart
				linePart.Parent = gui
				gridLineParts[u] = linePart
			elseif linePart.SelectionBox.Transparency ~= transparency or linePart.SelectionBox.Color ~= color then
				linePart.SelectionBox.Transparency = transparency
				linePart.SelectionBox.Color = color
			end
			local percent = (u - 1) / (gridSize - 1)
			linePart.Size = Vector3.new(gridCellSize * gridSize * sin(math.acos(percent * 1.8 - .9)), 0, 0)
			linePart.CFrame = baseCframe * CFrame.new(0, (percent - .5) * (gridSize - 1) * gridCellSize, 0) * CFrame.new(roundedNormalOffset)
		end
		for u = 1, gridSize do
			local linePart = gridLineParts[gridSize + u]
			if not linePart then
				linePart = Instance.new('Part')
				linePart.Transparency = 1
				linePart.TopSurface = 'Smooth'
				linePart.BottomSurface = 'Smooth'
				linePart.Anchored = true
				linePart.CanCollide = false
				linePart.formFactor = 'Custom'
				local selectionBox = Instance.new('SelectionBox')
				selectionBox.Color = color
				selectionBox.Transparency = transparency
				selectionBox.Adornee = linePart
				selectionBox.Parent = linePart
				linePart.Parent = gui
				gridLineParts[gridSize + u] = linePart
			elseif linePart.SelectionBox.Transparency ~= transparency or linePart.SelectionBox.Color ~= color then
				linePart.SelectionBox.Transparency = transparency
				linePart.SelectionBox.Color = color
			end
			local percent = (u - 1) / (gridSize - 1)
			linePart.Size = Vector3.new(0, gridCellSize * gridSize * sin(math.acos(percent * 1.8 - .9)), 0)
			linePart.CFrame = baseCframe * CFrame.new((percent - .5) * (gridSize - 1) * gridCellSize, 0, 0) * CFrame.new(roundedNormalOffset)
		end
	end

	local function getCell(list, x, y, z)
		return list and list[x] and list[x][y] and list[x][y][z]
	end

	local function getNeighborOccupancies(list, x, y, z, includeSelf)
		local fullNeighbor = false
		local emptyNeighbor = false
		local neighborOccupancies = includeSelf and getCell(list, x, y, z) or 0
		local totalNeighbors = includeSelf and 1 or 0
		local nearMaterial = materialDictionary[materialSelection]
		for axis = 1, 3 do
			for offset = -1, 1, 2 do
				local neighbor = nil
				if axis == 1 then
					neighbor = list[x + offset] and list[x + offset][y][z]
				elseif axis == 2 then
					neighbor = list[x][y + offset] and list[x][y + offset][z]
				elseif axis == 3 then
					neighbor = list[x][y][z + offset]
				end
				if neighbor then
					if neighbor >= 1 then
						fullNeighbor = true
					end
					if neighbor <= 0 then
						emptyNeighbor = true
					end
					totalNeighbors = totalNeighbors + 1
					neighborOccupancies = neighborOccupancies + neighbor
				end
			end
		end
		return neighborOccupancies / (totalNeighbors ~= 0 and totalNeighbors or getCell(list, x, y, z)), fullNeighbor, emptyNeighbor
	end

	local function round(n)
		return floor(n + .5)
	end

	function findFace()
		local cameraLookVector = game.Workspace.CurrentCamera.CoordinateFrame.lookVector
		--[[local absx = abs(cameraLookVector.x)		--this code is for 90 plane locking
		local absy = abs(cameraLookVector.y)
		local absz = abs(cameraLookVector.z)
		if absy >= absx and absy >= absz then	--preference towards y axis planes
			return Vector3.new(0, cameraLookVector.y / absy, 0)
		elseif absx >= absz then
			return	Vector3.new(cameraLookVector.x / absx, 0, 0)
		end
		return Vector3.new(0, 0, cameraLookVector.z / absz)]]

		return Vector3.new(round(cameraLookVector.x), round(cameraLookVector.y), round(cameraLookVector.z)).unit	--this code is for 45 degree plane locking
	end

	function lineToPlaneIntersection(linePoint, lineDirection, planePoint, planeNormal)
		local denominator = lineDirection:Dot(planeNormal)
		if denominator == 0 then
			return linePoint
		end
		local distance = ((planePoint - linePoint):Dot(planeNormal)) / denominator
		return linePoint + lineDirection * distance
	end


	function operation(centerPoint)
		local isDynamic = dynamicMaterial
		if forceDynamicMaterial then
			isDynamic = forceDynamicMaterialTo
		end
		local desiredMaterial = isDynamic and nearMaterial or materialDictionary[materialSelection]

		local radius = selectionSize * .5 * resolution
		local minBounds = Vector3.new(floor((centerPoint.x - radius) / resolution), floor((centerPoint.y - radius) / resolution), floor((centerPoint.z - radius) / resolution)) * resolution
		local maxBounds = Vector3.new(ceil((centerPoint.x + radius) / resolution), ceil((centerPoint.y + radius) / resolution), ceil((centerPoint.z + radius) / resolution)) * resolution
		local region = Region3.new(minBounds, maxBounds)

		local materials, occupancies = terrain:ReadVoxels(region, resolution)

		if modules[currentTool] then
			if modules[currentTool]['operation'] then

				local middle = materials[ceil(#materials * .5)]	--This little section of code sets nearMaterial to middle of matrix
				if middle then	--dig X
					local middle = middle[ceil(#middle * .5)]
					if middle then	--dig Y
						local middle = middle[ceil(#middle * .5)]
						if middle and middle ~= materialAir then	--dig Z
							nearMaterial = middle
							desiredMaterial = isDynamic and nearMaterial or materialDictionary[materialSelection]
						end
					end
				end

				modules[currentTool]['operation'](centerPoint, materials, occupancies, resolution, selectionSize, strength, desiredMaterial, brushShape, minBounds, maxBounds)
			end
		else

			for ix, vx in ipairs(occupancies) do
				local cellVectorX = minBounds.x + (ix - .5) * resolution - centerPoint.x

				for iy, vy in pairs(vx) do
					local cellVectorY = minBounds.y + (iy - .5) * resolution - centerPoint.y

					for iz, cellOccupancy in pairs(vy) do
						local cellVectorZ = minBounds.z + (iz - .5) * resolution - centerPoint.z

						local cellMaterial = materials[ix][iy][iz]
						local distance = sqrt(cellVectorX * cellVectorX + cellVectorY * cellVectorY + cellVectorZ * cellVectorZ)
	
						local magnitudePercent = 1
						local brushOccupancy = 1
						if brushShape == 'Sphere' then
							magnitudePercent = cos(min(1, distance / (radius + resolution * .5)) * pi * .5)
							brushOccupancy = max(0, min(1, (radius + .5 * resolution - distance) / resolution))
						elseif brushShape == 'Box' then
							if not (snapToGrid or forceSnapToGrid) then
								local xOutside = 1 - max(0, abs(cellVectorX / resolution) + .5 - selectionSize * .5)
								local yOutside = 1 - max(0, abs(cellVectorY / resolution) + .5 - selectionSize * .5)
								local zOutside = 1 - max(0, abs(cellVectorZ / resolution) + .5 - selectionSize * .5)
								brushOccupancy = xOutside * yOutside * zOutside
							end
						end

						if cellMaterial ~= materialAir and cellMaterial ~= nearMaterial then
							nearMaterial = cellMaterial
							if isDynamic then
								desiredMaterial = nearMaterial
							end
						end
	
						if currentTool == 'Add' then
							if selectionSize <= 2 then
								if brushOccupancy >= .5 then
									if cellMaterial == materialAir or cellMaterial == materialWater or cellOccupancy <= 0 then
										materials[ix][iy][iz] = desiredMaterial
									end
									occupancies[ix][iy][iz] = 1
								end 
							else
								if brushOccupancy > cellOccupancy then
									occupancies[ix][iy][iz] = brushOccupancy
								end
								if brushOccupancy >= .5 and (cellMaterial == materialAir or cellMaterial == materialWater) then
									materials[ix][iy][iz] = desiredMaterial
								end
							end
						elseif currentTool == 'Subtract' then
							if selectionSize <= 2 then
								if brushOccupancy >= .5 then
									occupancies[ix][iy][iz] = 0
									materials[ix][iy][iz] = materialAir
								end
							else
								local desiredOccupancy = 1 - brushOccupancy
								if desiredOccupancy < cellOccupancy then
									occupancies[ix][iy][iz] = desiredOccupancy
								end
								if desiredOccupancy <= 0 then
									materials[ix][iy][iz] = materialAir
								end
							end
						elseif currentTool == 'Grow' then
							if brushOccupancy >= .5 then
								local desiredOccupancy = cellOccupancy
								local neighborOccupancies, fullNeighbor ,emptyNeighbor = getNeighborOccupancies(occupancies, ix, iy, iz)
								if cellOccupancy > 0 or fullNeighbor then	--problem if selection size is small.
									desiredOccupancy = desiredOccupancy + neighborOccupancies * (strength + .1) * .25 * brushOccupancy * magnitudePercent
								end
								if cellMaterial == materialAir or cellOccupancy <= 0 and desiredOccupancy > 0 then
									materials[ix][iy][iz] = desiredMaterial
								end
								occupancies[ix][iy][iz] = desiredOccupancy
							end
						elseif currentTool == 'Erode' then
							local flippedBrushOccupancy = 1 - brushOccupancy
							if flippedBrushOccupancy <= .5 then
								local desiredOccupancy = cellOccupancy
								local emptyNeighbor = false
								local neighborOccupancies = 6
								for axis = 1, 3 do
									for offset = -1, 1, 2 do
										local neighbor = nil
										if axis == 1 then
											neighbor = occupancies[ix + offset] and occupancies[ix + offset][iy][iz]
										elseif axis == 2 then
											neighbor = occupancies[ix][iy + offset] and occupancies[ix][iy + offset][iz]
										elseif axis == 3 then
											neighbor = occupancies[ix][iy][iz + offset]
										end
										if neighbor then
											if neighbor <= 0 then
												emptyNeighbor = true
											end
											neighborOccupancies = neighborOccupancies - neighbor
										end
									end
								end
								if cellOccupancy < 1 or emptyNeighbor then
									desiredOccupancy = desiredOccupancy - (neighborOccupancies / 6) * (strength + .1) * .25 * brushOccupancy * magnitudePercent
								end
								if cellMaterial == materialAir or cellOccupancy <= 0 and desiredOccupancy > 0 then
									materials[ix][iy][iz] = desiredMaterial
								end
								occupancies[ix][iy][iz] = desiredOccupancy
							end
						elseif currentTool == 'Paint' then
							if brushOccupancy > 0 and cellOccupancy > 0 then
								materials[ix][iy][iz] = desiredMaterial
							end
						end
					end
				end
			end
		end
		terrain:WriteVoxels(region, resolution, materials, occupancies)
	end

	
	function Selected(toolButton, toolName)
		plugin:Activate(true)
		if toolButton then
			toolButton:SetActive(true)
			lastToolButton = toolButton
		end
		on = true
		currentTool = toolName

		if modules[toolName] and modules[toolName]['On'] then
			modules[toolName].On(mouse,Deselected)
		end
		if not modules[toolName] or modules[toolName]['operation'] then

			gui.Parent = coreGui
	
			forcePlaneLock = toolName == 'Add' or toolName == 'Subtract'
			updatePlaneLock()

			forceDynamicMaterial = toolName == 'Subtract' or toolName == 'Erode' or toolName == 'Paint' or toolName == 'Smooth' or toolName == 'Smoother'
			forceDynamicMaterialTo = not (forceDynamicMaterial and toolName == 'Paint')
			updateDynamicMaterial()
	
			local loopTag = {}	--using table as a unique value for debouncing
			currentLoopTag = loopTag
	
			while currentLoopTag and currentLoopTag == loopTag do
				local t = tick()
				local radius = selectionSize * .5 * resolution
				
				local mainPoint = mouse.Hit.p
	
				if toolName == 'Add' then
					mainPoint = mainPoint - mouse.UnitRay.Direction * .05
				elseif toolName == 'Subtract' or toolName == 'Paint' or toolName == 'Grow' then
					mainPoint = mainPoint + mouse.UnitRay.Direction * .05
				end
	
				if mouse.Target == nil then	--cage the cursor so that it does not fly away
					mainPoint = game.Workspace.CurrentCamera.CoordinateFrame.p + mouse.UnitRay.Direction * lastCursorDistance --limits the distance of the mainPoint if the mouse is not hitting an object
				end
	
				if not mouseDown or click then
					lastPlanePoint = mainPoint
					lastNormal = findFace()
				end
	
				if planeLock or forcePlaneLock then
					mainPoint = lineToPlaneIntersection(mouse.Hit.p, mouse.UnitRay.Direction, lastPlanePoint, lastNormal)
				end
	
				if snapToGrid or forceSnapToGrid then
					local snapOffset = Vector3.new(1, 1, 1) * (radius % resolution)		--in studs
					local tempMainPoint = (mainPoint - snapOffset) / resolution + Vector3.new(.5, .5, .5)	--in voxels
					mainPoint = Vector3.new(floor(tempMainPoint.x), floor(tempMainPoint.y), floor(tempMainPoint.z)) * resolution + snapOffset
				end
	
				if mouseDown then
					if click then
						firstOperation = t
						lastMainPoint = mainPoint
					end
					if click or t > firstOperation + clickThreshold then
						click = false
						local difference = mainPoint - lastMainPoint
						local dragDistance = (difference).magnitude
						local crawlDistance = radius * .5			--Maybe adjustable setting? Considering using a different method of crawling, with a percent rather than a finite distance.
						if dragDistance > crawlDistance then
							local differenceVector = difference.unit
							local dragDistance = min(dragDistance, crawlDistance * 2 + 20)	--limiting this so that it does not attempt too many operations within a single drag.
							local samples=ceil(dragDistance / crawlDistance - .1)
							for i = 1, samples do
								operation(lastMainPoint + differenceVector * dragDistance * (i / samples))
							end
							mainPoint = lastMainPoint + differenceVector * dragDistance
						else
							operation(mainPoint)
						end
						lastMainPoint = mainPoint
					end
				end
	
				if not selectionPart then
					selectionPart = Instance.new('Part')
					selectionPart.Name = 'SelectionPart'
					selectionPart.Transparency = 1
					selectionPart.TopSurface = 'Smooth'
					selectionPart.BottomSurface = 'Smooth'
					selectionPart.Anchored = true
					selectionPart.CanCollide = false
					selectionPart.formFactor = 'Custom'
					selectionPart.Size = Vector3.new(1, 1, 1) * selectionSize * resolution + Vector3.new(.1, .1, .1)
					selectionPart.Parent = gui
				end
				if not selectionObject then
					selectionObject = Instance.new(brushShape == 'Sphere' and 'SelectionSphere' or 'SelectionBox')
					selectionObject.Name = 'SelectionObject'
					selectionObject.Color = BrickColor.new('Toothpaste')
					selectionObject.SurfaceTransparency = .95 - strength * .3
					selectionObject.SurfaceColor = BrickColor.new('Toothpaste')
					selectionObject.Adornee = selectionPart
					selectionObject.Parent = selectionPart
				end
				selectionPart.CFrame = CFrame.new(mainPoint)
	
				if planeLock or forcePlaneLock then
					local mainPointIntersect = lineToPlaneIntersection(mainPoint, mouse.UnitRay.Direction, lastPlanePoint, lastNormal)	--we need to get this otherwise the plane can shift whiel drawing
					drawGrid(mainPointIntersect, lastNormal, mouseDown and .8)
				end
	
				lastCursorDistance = max(20 + selectionSize * resolution * 1.5,(mainPoint - game.Workspace.CurrentCamera.CoordinateFrame.p).magnitude)
	
				quickWait()
			end
		end
	end
	
	function Deselected()
		currentLoopTag = nil
		gui.Parent = script.Parent
		clearSelection()
		clearGrid()
		if lastToolButton then
			lastToolButton:SetActive(false)
		end
		mouseDown = false
		on = false
		local lastCurrentTool = currentTool
		currentTool = nil
		if modules[lastCurrentTool] and modules[lastCurrentTool]['Off'] then
			modules[lastCurrentTool].Off()
		end
	end

	function scrollwheel(change)
		if on then
			if downKeys[Enum.KeyCode.LeftShift] or downKeys[Enum.KeyCode.RightShift] then
				selectionSize = max(minSelectionSize, min(maxSelectionSize, selectionSize + change))
				selectionSizeValue.Value = selectionSize
			end
			if downKeys[Enum.KeyCode.LeftControl] or downKeys[Enum.KeyCode.RightControl] then
				strength = max(0, min(1, strength + change * (1/(maxSelectionSize-minSelectionSize))))
				strengthValue.Value = round(strength * 100 + 1)
			end
		end
	end

	userInput.InputBegan:connect(function(event, soaked)
		downKeys[event.KeyCode] = true
		if event.UserInputType == Enum.UserInputType.MouseButton1 and not soaked and on then
			mouseDown = true
			click = true
		end
	end)
	userInput.InputEnded:connect(function(event, soaked)
		downKeys[event.KeyCode] = nil
		if event.UserInputType == Enum.UserInputType.MouseButton1 and mouseDown then
			mouseDown = false
			changeHistory:SetWaypoint('Terrain '..currentTool)
		end
	end)
	mouse.WheelForward:connect(function()
		scrollwheel(1)
	end)
	mouse.WheelBackward:connect(function()
		scrollwheel(-1)
	end)

	--[[mouse.Button1Down:connect(function()
		if on then
			mouseDown = true
			click = true
		end
	end)
	mouse.Button1Up:connect(function()
		mouseDown = false
		changeHistory:SetWaypoint('Terrain '..currentTool)
	end)]]

	closeButton.MouseButton1Down:connect(Deselected)

	plugin.Deactivation:connect(function()
		if on then
			Deselected()
		end
	end)

	setBrushShape(brushShape)
	setMaterialSelection(materialSelection)
	updatePlaneLock()
	updateSnapToGrid()
	updateDynamicMaterial()
end


]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX5AA344794882428EAC47424BB83AECC7">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">GenerationModule</string>
				<ProtectedString name="Source"><![CDATA[-- Wait for the things we need to arrive
game:WaitForChild("Workspace")
game.Workspace:WaitForChild("Terrain")

-- Local copy of terrain to call on throughout the script for speed
local terrain = game.Workspace.Terrain


-----------------------------------
--DEFAULT SETTINGS FOR GENERATION--
-----------------------------------
local TerrainOptions = {}
do
--============== General Settings ============--
	-- Offset to create terrain at.
	-- note, offset can't be set in the GUI, but it's useful
	-- to at least have it available.
	TerrainOptions.xpos = 0
	TerrainOptions.zpos = 0
	-- Size of area to generate
	TerrainOptions.width = 400  -- width  ~ x size
	TerrainOptions.length = 300 -- length ~ z size
	-- How how the base of the world should be.
	TerrainOptions.baseHeight = 1


--=============== Hill Settings ===============--
	-- How sharp or smooth to make the hills
	TerrainOptions.hillSizeModifier = 1
	-- Should cliffs be generated?
	TerrainOptions.enableCliffs = true
	-- How dense is the cliff generation?
	TerrainOptions.cliffDensityModifier = 1


--============= Mountain Settings =============--
	-- What region to apply mountains to?
	TerrainOptions.mountainMode = "Ridge"
	-- Mountain Frequency, how often mountains occur in the region?
	-- This is a global mask value to apply to mountains, with the formula:
	-- Terrain = mountainlayerAndMask * mountainFrequency + 
	--           otherlayers * 1-mountainFrequency
	TerrainOptions.mountainFrequency = .9
	-- the max height of mountains
	TerrainOptions.mountainHeight = 56
	-- The average size of mountains to make, in terms of a fraction of the map size
	TerrainOptions.mountainSize = 0.15


--============== Water Settings ===============--
	-- Lake frequency, how many lakes to place per square in the generated terrain. 
	TerrainOptions.lakesPerSquare = 1/10000
	-- how large can the lakes be?
	TerrainOptions.lakeMaxSize = 3000
	-- what should the sea level be?
	TerrainOptions.sealevel = 0


--============= Vegetation Settings ===========--
-- Note: Vegetation generation is not included,
--       in the GUI, but still present in the
--       code if someone wants to play with it.
	-- vegetation mode
	TerrainOptions.vegetationMode = false
	-- vegetation density
	TerrainOptions.vegetationDensity = 1/100


--============== Material Settings ============--
	-- How to color the level
	TerrainOptions.baseColor = 1               -- What material to use for solid color,
	                                           -- and for the main parts of the generation.
	TerrainOptions.colorMode = "Auto Color" -- Values: [Solid Color, Auto Color]
	TerrainOptions.colorMountains = true       -- color steep slopes in a grey color
	TerrainOptions.snowtoppedMountains = false -- color mountain peaks with white
	TerrainOptions.addSandyRegions = false     -- color some of the base with sand
	TerrainOptions.colorCliffs = true          -- color clif faces with a marbled texture
	TerrainOptions.soilDepth = 4               -- where soil is, how deep should it be? (with rock below)
end
local snowMaterial = Enum.Material.Slate


-- This will store a copy of TerrainOptions when the generate button is pressed.
-- This will then be used for the generation instead of TerrainOptions.  This way 
-- TerrainOptions can be changed while generating without messing up what is being 
-- generated.
local GenerateOptions = nil


---------------------
--UTILITY FUNCTIONS--
---------------------
-- Create a deep copy of a table.
-- Copies the elements.
function CopyTable(object)
    local holdTable = {}
    local function Copy(object)
        if type(object) ~= "table" then
            return object
        elseif holdTable[object] then
            return holdTable[object]
        end
        local clone = {}
        holdTable[object] = clone
        for index, value in pairs(object) do
            clone[Copy(index)] = Copy(value)
        end
        return setmetatable(clone, getmetatable(object))
    end
    return Copy(object)
end


------------------
--DEFAULT VALUES--
------------------
-- has the plugin been loaded?
local loaded = false

-- is the plugin currently active?
local on = false

-- Stores the conformation popup when confirming a choice.  If not nil then some actions should be blocked.
local ConfirmationPopupObject = nil

-- If true, the clear terrain conformation won't be shown.
local hideClearConformation = false

-- If true, the genearte terrain conformation won't be shown.
local hideGenerateConformation = false


----------------
--PLUGIN SETUP--
----------------
-- an event that is fired before the plugin deactivates
local deactivatingEvent = Instance.new("BindableEvent")

-- create the plugin and toolbar, and connect them to the On/Off activation functions
--[[local plugin = PluginManager():CreatePlugin()
plugin.Deactivation:connect(function()
	Off()
end)
local toolbar = plugin:CreateToolbar("Terrain")
local toolbarbutton = toolbar:CreateButton("New Smooth Terrain", "Terrain Generator", "")
toolbarbutton.Click:connect(function()
	if on then
		deactivatingEvent:Fire()
		Off()
	elseif loaded then
		On()
	end
end)]]


--==========================================================================================================--
--==                                     Noise generation code                                            ==--
--==========================================================================================================--
--
local perm = {
	151,160,137,91,90,15,
	131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
	190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
	88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
	77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
	102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
	135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
	5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
	223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
	129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
	251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
	49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
	138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,
	151,160,137,91,90,15,
	131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
	190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
	88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
	77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
	102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
	135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
	5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
	223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
	129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
	251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
	49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
	138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
}
local floor = math.floor
local function grad( hash, x, y )
    local h = hash%8;          -- Convert low 3 bits of hash code
    local u = h<4 and x or y;  -- into 8 simple gradient directions,
    local v = h<4 and y or x;  -- and compute the dot product with (x,y).
    return ((h%2==1) and -u or u) + ((floor(h/2)%2==1) and -2.0*v or 2.0*v);
end
local function PerlinNoise(x,y)
    local ix0, iy0, ix1, iy1;
    local fx0, fy0, fx1, fy1;
    local s, t, nx0, nx1, n0, n1;

    ix0 = floor(x); -- Integer part of x
    iy0 = floor(y); -- Integer part of y
    fx0 = x - ix0;        -- Fractional part of x
    fy0 = y - iy0;        -- Fractional part of y
    fx1 = fx0 - 1.0;
    fy1 = fy0 - 1.0;
    ix1 = (ix0 + 1) % 255;  -- Wrap to 0..255
    iy1 = (iy0 + 1) % 255;
    ix0 = ix0 % 255;
    iy0 = iy0 % 255;
    
	t=(fy0*fy0*fy0*(fy0*(fy0*6-15)+10));
	s=(fx0*fx0*fx0*(fx0*(fx0*6-15)+10));

    nx0 = grad(perm[ix0 + perm[iy0+1]+1], fx0, fy0);
    nx1 = grad(perm[ix0 + perm[iy1+1]+1], fx0, fy1);
    n0 = nx0 + t*(nx1-nx0);

    nx0 = grad(perm[ix1 + perm[iy0+1]+1], fx1, fy0);
    nx1 = grad(perm[ix1 + perm[iy1+1]+1], fx1, fy1);
    n1 = nx0 + t*(nx1-nx0);

    return 0.5*(1 + (0.507 * (n0 + s*(n1-n0))))
end
function PerlinNoiseMap(lambda)
	local key = math.random()*10000
	local map = {}
	for x = 1, GenerateOptions.width do
		map[x] = {}
		for z = 1, GenerateOptions.length do
			map[x][z] = PerlinNoise(x/lambda, z/lambda + key)
		end
	end
	return map
end
-- end perlin noise generation code


--==========================================================================================================--
--                                       GUI Utility functions                                            ==--
--==========================================================================================================--

local newgui=script.Parent:WaitForChild('TerrainGenerationGui')
local newguiFrame = newgui:WaitForChild('Frame')
local scrollingFrame = newguiFrame:WaitForChild('ScrollingFrame')
local canvasFrame = scrollingFrame:WaitForChild('Canvas')
local coreGui = game:GetService('CoreGui')

-- UI gui load.  Required for all the GUI code
local RbxGui = LoadLibrary("RbxGui")

-- Create a standard text label.  Use this for all lables in the popup so it is easy to standardize.
-- labelName - What to set the text label name as.
-- pos    	 - Where to position the label.  Should be of type UDim2.
-- size   	 - How large to make the label.	 Should be of type UDim2.
-- text   	 - Text to display.
-- parent 	 - What to set the text parent as.
-- Return:
-- Value is the created label.
function CreateStandardLabel(labelName,
                             pos,
							 size,
							 text,
							 parent)
	local label = Instance.new("TextLabel", parent)
	label.Name = labelName
	label.Position = pos
	label.Size = size
	label.Text = text
	label.TextColor3 = Color3.new(0.95, 0.95, 0.95)
	label.Font = Enum.Font.ArialBold
	label.FontSize = Enum.FontSize.Size14
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.BackgroundTransparency = 1	
	label.Parent = parent	
	
	return label
end

-- Create a standardized slider.
-- name  - Name to use for the slider.
-- pos   - Position to display the slider at.
-- steps - How many steps there are in the slider.
-- funcOnChange - Function to call when the slider changes.
-- initValue    - Initial value to set the slider to.  If nil the slider stays at the default. 
-- parent       - What to set as the parent.
-- Return:
-- sliderGui      - Slider gui object.
-- sliderPosition - Object that can set the slider value.
function CreateStandardSlider(name,
                              pos,
							  lengthBarPos,
							  steps,
							  funcOnChange,
							  initValue,
							  parent)
	local sliderGui, sliderPosition = RbxGui.CreateSlider(steps, 0, UDim2.new(0,0,0,0))
	
	sliderGui.Name = name
	sliderGui.Parent = parent
	sliderGui.Position = pos
	sliderGui.Size = UDim2.new(1,0,0,20)
	local lengthBar = sliderGui:FindFirstChild("Bar")
	lengthBar.Size = UDim2.new(1, -21, 0, 5)
	lengthBar.Position = lengthBarPos
	
	if nil ~= funcOnChange then
		sliderPosition.Changed:connect(function() funcOnChange(sliderPosition) end)
	end
	
	if nil ~= initValue then 
		sliderPosition.Value = initValue
	end
	
	return sliderGui, sliderPosition 
end


-- Create a standard dropdown.  Use this for all dropdowns in the popup so it is easy to standardize.
-- name - What to set the text label name as.
-- pos    	 	 - Where to position the label.  Should be of type UDim2.
-- values    	 - A table of the values that will be in the dropbox, in the order they are to be shown.
-- initValue	 - Initial value the dropdown should be set to.
-- funcOnChange  - Function to run when a dropdown selection is made.
-- parent 	 	 - What to set the parent as.
-- Return:
-- dropdown 	   - The dropdown gui.
-- updateSelection - Object to use to change the current dropdown.																																		
function CreateStandardDropdown(name,
						        pos,
								values,
								initValue,
								funcOnChange,
								parent)					
	-- Create a dropdown selection for the modes to fill in a river
	local dropdown, updateSelection=RbxGui.CreateDropDownMenu(values, funcOnChange);
	dropdown.Name = name
	dropdown.Position = pos
	dropdown.Active = true
	dropdown.Size = UDim2.new(0,150,0,32)
	dropdown.Parent = parent

	updateSelection(initValue)		

	return dropdown, updateSelection
end		

-- Keep common button properties here to make it easer to change them all at once.
-- These are the default properties to use for a button.
buttonTextColor = Color3.new(1, 1, 1);
buttonFont = Enum.Font.ArialBold;
buttonFontSize = Enum.FontSize.Size18;

-- Create a standard dropdown.  Use this for all dropdowns in the popup so it is easy to standardize.
-- name - What to use.
-- pos    	 	- Where to position the button.  Should be of type UDim2.
-- text         - Text to show in the button.
-- funcOnPress  - Function to run when the button is pressed.
-- parent 	 	- What to set the parent as.
-- Return:
-- button 	   - The button gui.																																	
function CreateStandardButton(name,
  							  pos,
							  text,
							  funcOnPress,
							  parent,
							  size)					
	local button = Instance.new("TextButton", parent)
	button.Name = name
	button.Position = pos

	button.Size = UDim2.new(0,120,0,40)
	button.Text = text

	if size then
		button.Size = size
	end
	
	button.Style = Enum.ButtonStyle.RobloxButton

	button.TextColor3 = buttonTextColor
	button.Font = buttonFont
	button.FontSize = buttonFontSize

	button.MouseButton1Click:connect(funcOnPress)
	
	return button
end	



function createSection(name, pos, size, parent)
	local sectionGui = newgui:WaitForChild('TemplateSection'):clone()
	sectionGui.Name = 'Section'..name
	sectionGui.Text = name
	sectionGui.Position = UDim2.new(0,0,0,pos)
	sectionGui.Frame.Size = UDim2.new(1,0,0,size)
	sectionGui.Parent = parent
	sectionGui.Visible = true
	return sectionGui, sectionGui.Frame
end

function createCheckBox(name, pos, parent, setting, changedFunction)
	local setting = setting
	local checkBoxGui = newgui:WaitForChild('TemplateCheckBox'):clone()
	checkBoxGui.Name = 'CheckBox'..name
	checkBoxGui.Label.Text = name
	checkBoxGui.Text = setting and 'X' or ''
	checkBoxGui.Position = UDim2.new(0,4,0,pos)
	checkBoxGui.Parent = parent
	checkBoxGui.Visible = true
	checkBoxGui.MouseButton1Down:connect(function()
		setting = not setting
		checkBoxGui.Text = setting and 'X' or ''
		changedFunction(setting)
	end)
	return checkBoxGui
end


-- Create a standard accordion, which contains many child areas that can be
-- swiched between
-- name
-- pos           - Where to put it
-- childList     - List of children to add, format: [{Name = ..., Gui = ..., Height = ...}]
-- 
function CreateStandardAccordion(name, 
	                             pos, 
	                             size, 
	                             childList, 
	                             parent)
	local frame = Instance.new('Frame', parent)
	frame.Position = pos
	frame.Size = size
	frame.Name = name
	frame.ClipsDescendants = true
	frame.BackgroundTransparency = 1
	--
	local childContainerList = {}
	--
	local function doLayout(pressedItem)
		local atY = 0
		for _, child in pairs(childContainerList) do
			child.Gui.Position = UDim2.new(0, 0, 0, atY)
			if child == pressedItem then
				child.Gui.Size = UDim2.new(1, 0, 0, child.DesiredHeight)
				child.Gui.HeadingButton.TextColor3 = Color3.new(1, 0.7, 0.7)
				child.ChildGui.Visible = true
				atY = atY + child.DesiredHeight
			else
				child.Gui.Size = UDim2.new(1, 0, 0, 40)
				child.Gui.HeadingButton.TextColor3 = buttonTextColor
				child.ChildGui.Visible = false
				atY = atY + 25
			end
		end
	end
	--
	for _, childData in pairs(childList) do
		local childContainer = Instance.new('Frame', frame)
		childContainer.BackgroundTransparency = 1
		childContainer.ClipsDescendants = true
		--
		local childHeader = Instance.new('TextButton', childContainer)
		childHeader.Name = 'HeadingButton'
		childHeader.Style = Enum.ButtonStyle.RobloxButton
		childHeader.Size = UDim2.new(1, 0, 0, 30)
		childHeader.TextColor3 = buttonTextColor
		childHeader.Font = buttonFont
		childHeader.FontSize = buttonFontSize
		childHeader.Text = " v "..childData.Name.." v "
		--
		childData.Gui.BackgroundTransparency = 1
		childData.Gui.Position = UDim2.new(0, 0, 0, 30)
		childData.Gui.Size = UDim2.new(1, 0, 1, -30)
		childData.Gui.Parent = childContainer
		--
		local data = {
			Gui = childContainer;
			ChildGui = childData.Gui;
			DesiredHeight = childData.Height + 30;
		}
		childContainerList[#childContainerList+1] = data
		--
		childHeader.MouseButton1Click:connect(function() doLayout(data) end)
	end
	--do an initial layout
	doLayout(childContainerList[1])
	--
	return frame
end

-- Confirmation Popup GUI
ConfirmationPopup = {}
ConfirmationPopup.__index = ConfirmationPopup					 
do 
	-- Create a confirmation popup.
	--
	-- confirmText       - What to display in the popup.
	-- confirmButtonText - What to display in the popup.
	-- declineButtonText - What to display in the popup.
	-- confirmFunction   - Function to run on confirmation.
	-- declineFunction   - Function to run when declining.
	--
	-- Return:
	-- Value a table with confirmation gui and options.	
	function ConfirmationPopup.Create(confirmText,
									  confirmButtonText,
									  declineButtonText,
								      confirmFunction,
								      declineFunction)			  
		local popup = {}
		popup.confirmButton = nil			-- Hold the button to confirm a choice.
		popup.declineButton = nil			-- Hold the button to decline a choice.		 			 
		popup.confirmationFrame = nil       -- Hold the conformation frame.
		popup.confirmationText = nil        -- Hold the text label to display the conformation message.
		popup.confirmationHelpText = nil    -- Hold the text label to display the conformation message help.


		popup.confirmationFrame = Instance.new("Frame", MainScreenGui)
		popup.confirmationFrame.Name = "ConfirmationFrame"
		popup.confirmationFrame.Size = UDim2.new(0, 280, 0, 140)
		popup.confirmationFrame.Position = UDim2.new(.5, -popup.confirmationFrame.Size.X.Offset/2, 0.5, -popup.confirmationFrame.Size.Y.Offset/2)
		popup.confirmationFrame.Style = Enum.FrameStyle.RobloxRound
		popup.confirmLabel = CreateStandardLabel("ConfirmLabel", UDim2.new(0,0,0,15), UDim2.new(1, 0, 0, 24), confirmText, popup.confirmationFrame)
		popup.confirmLabel.FontSize = Enum.FontSize.Size18
		popup.confirmLabel.TextXAlignment = Enum.TextXAlignment.Center

		-- Confirm
		popup.confirmButton = CreateStandardButton("ConfirmButton",
											UDim2.new(0.5, -120, 1, -50),
										    confirmButtonText,
										    confirmFunction,
										    popup.confirmationFrame)	

		-- Decline
		popup.declineButton  = CreateStandardButton("DeclineButton",
											UDim2.new(0.5, 0, 1, -50),
										    declineButtonText,
										    declineFunction,
										    popup.confirmationFrame)										

		setmetatable(popup, ConfirmationPopup)

		return popup
	end	

	-- Clear the popup, free up assets.
	function ConfirmationPopup:Clear()

		if nil ~= self.confirmButton then
			self.confirmButton.Parent = nil
		end

		if nil ~= self.declineButton then
			self.declineButton.Parent = nil	
		end

		if nil ~= self.confirmationFrame then
			self.confirmationFrame.Parent = nil
		end

		if nil ~= self.confirmLabel then
			self.confirmLabel.Parent = nil    
		end

		self.confirmButton = nil
		self.declineButton = nil			 
		self.conformationFrame = nil
		self.conformText = nil      
	end
end

--==========================================================================================================--
--                                        Progres Bar Handling                                            ==--
--==========================================================================================================--

-- Container used to store the data about the progress bar. The style of the stupid 
-- RbxGui library gives us a whole bunch of return values when creating one, and
-- sticking them all in a table is the best way to deal with them.
CancelValues = {cancelAction = false, -- Used to cancel currently occuring actions.  If set to true then terrain generation will stop.
				progressBar = nil, 	  -- Will store the progress bar when needed.
				setAmountFunc = nil,  -- Stores a function tied to the progres bar that sets the progress bar precentage done.
				bindForCancel = nil}  -- Stores a function bind that will be set with the function to run when the cancel button is pressed in the progress bar.

-- Load the progress bar to display when drawing a river.
-- text - Text to display.
function LoadProgressBar(text)
	if CancelValues.progressBar == nil then
		CancelValues.isDrawing = true
		
		-- Start the progress bar.
		CancelValues.progressBar, CancelValues.setAmountFunc, CancelValues.bindForCancel = RbxGui.CreateLoadingFrame(text)
		CancelValues.progressBar.Position = UDim2.new(.5, -CancelValues.progressBar.Size.X.Offset/2, 0, 15)
		CancelValues.progressBar.Parent = MainScreenGui
		CancelValues.bindForCancel.Event:connect(function(arguments)
			CancelValues.cancelActions = true		-- Set the flag that everything should stop.
			coroutine.yield()   -- No idea why this is here?????? Breaks without it, don't remove.
		end)
	else
		print('Tried to start the progress bar when it was already running.')
	end
end

-- Unload the progress bar.
function UnloadProgressBar()
	CancelValues.isDrawing = false
	CancelValues.cancelActions = false
	
	if nil ~= CancelValues.progressBar then
		CancelValues.progressBar.Parent = nil
		CancelValues.progressBar = nil
		CancelValues.setAmountFunc = nil
		CancelValues.bindForCancel = nil
	end
end															


--==========================================================================================================--
--                           Main Terrain generation and clearing code                                    ==--
--==========================================================================================================--

-- Set the camera to look at the terrain from a distance so that all terrain will be in view.
-- centerX, centerZ - Center coordinate of land.  This doesn't take into account clipping.
-- length, width    - Land dimensions.
function SetCamera(centerX, centerZ, length, width)
	local currCamera = game.Workspace.CurrentCamera
	local cameraPos = Vector3.new(0, 400, 1600)
	local cameraFocus = Vector3.new(0, 255, 0)
	
	-- Nothing set so use the default.
	if nil ~= centerX then
		local scale = 0
		local lengthScale = 0
		local widthScale = 0
		
		if length <= 64 then
			lengthScale = .35
		elseif length <= 128 then
			lengthScale = .5
		elseif length <= 256 then
			lengthScale = .7
		else
			lengthScale = 1.3
		end
		
		if width <= 64 then
			widthScale = .35
		elseif width <= 128 then
			widthScale = .4
		elseif width <= 256 then
			widthScale = .4
		else
			widthScale = .7
		end		
		
		if widthScale > lengthScale then
			scale = widthScale
		else
			scale = lengthScale
		end

		local distance = Vector3.new(0, (200*scale) + 200, (1100*scale))
		cameraPos = Vector3.new(centerX + distance.X, distance.Y, centerZ + distance.Z)
		cameraFocus = Vector3.new(centerX, 0, centerZ)
	end	
	
	currCamera.CoordinateFrame = CFrame.new(cameraPos.X, cameraPos.Y, cameraPos.Z)
	currCamera.Focus = CFrame.new(cameraFocus.X, cameraFocus.Y, cameraFocus.Z)	
end

-- Function used by the clear button.  Prompts the user first.
-- Will not show if disabled or terrain is being processed.
function ConfirmClearTerrain()
	-- Only do if something isn't already being processed.
	if nil == CancelValues.progressBar then
		if nil == ConfirmationPopupObject then
			if not hideClearConformation then
				ConfirmationPopupObject = ConfirmationPopup.Create("Clear Terrain?",
														     "Clear",
														     "Cancel",
															 function()
																 ClearConformation()
																 ClearTerrain()
															 end, 
															 ClearConformation,
															 function() 
																hideClearConformation = not hideClearConformation 
																return not hideClearConformation
															end)
			else
				ClearTerrain()
			end
		end
	end
end

-- Function used by the generate button.  Prompts the user first.
-- Will not show if disabled or terrain is being processed.
function ConfirmGenerateTerrain()
	-- Only do if something isn't already being processed.
	if nil == CancelValues.progressBar then	
		if nil == ConfirmationPopupObject then
			if not hideGenerateConformation then
				ConfirmationPopupObject = ConfirmationPopup.Create("Generate Terrain?",
															 "Generate",
															 "Cancel",
															 function()
																 ClearConformation()
																 GenerateTerrain()
															 end, 
															 ClearConformation,
															 function() 
																hideGenerateConformation = not hideGenerateConformation 
																return not hideGenerateConformation
															 end)
			else
				GenerateTerrain()
			end
		end
	end
end

-- Unload the conformation popup if it exists.			   
-- Does nothing if the popup isn't set.
function ClearConformation()
	if nil ~= ConfirmationPopupObject then
		ConfirmationPopupObject:Clear()
		ConfirmationPopupObject = nil
	end
end	

-- Create terrain based on the current properties.
function GenerateTerrain()
	-- don't let the user fiddle with things while we're running the generator
	--toolbarbutton:SetActive(false)
	
	-- Make the cache of the TerrainOptions to use for our generation settings, that can't get messed with
	-- while we're generating.
	GenerateOptions = CopyTable(TerrainOptions)

	-- Turn off the plugin to give the user a better view, and disuade them from trying something silly
	-- like generating twice at the same time.
	Off()
	
	-- Create the progress bar that will track terrain creation completion.
	LoadProgressBar("Generating Terrain")

	-- Reposition to get a good view.
	SetCamera(GenerateOptions.xpos, GenerateOptions.zpos, GenerateOptions.length, GenerateOptions.width)


	------------------------------------------------------------------------------------------------------
	-- Update the message displayed to the user durring generation
	------------------------------------------------------------------------------------------------------
	local function UpdateGenerationProgressMessage(text)
		CancelValues.progressBar.loadingName.Text = text
	end


	------------------------------------------------------------------------------------------------------
	-- Easy pausing code, which will only wait at most once every 1/9 second
	-- Lets us generate faster without completely freezing the game from the user's perspective.
	------------------------------------------------------------------------------------------------------
	local LastPause = tick()
	local function pause()
		if tick()-LastPause > 1/6 then
			wait()
			LastPause = tick()
		end
	end


	------------------------------------------------------------------------------------------------------
	-- Tree model management. Vegetation is placed in here if enabled.
	------------------------------------------------------------------------------------------------------
	local function GetTreeModel()
		local model = game.Workspace:FindFirstChild('TreeModel')
		if not model then
			model = Instance.new('Model', game.Workspace)
			model.Name = 'TreeModel'
		end
		return model
	end



	------------------------------------------------------------------------------------------------------
	-- Some fixed settings that haven't migrated to the TerrainOptions yet because they're carefully
	-- hard coded values.
	------------------------------------------------------------------------------------------------------
	local CLIFFS_PER_SQ = 1/2000
	--
	local MIDDLE_RIDGE_RADIUS =   40  --the base radius of the middle ridge
	local MIDDLE_RIDGE_VARIANCE = 50  --how much to vary the boundary by
	local MIDDLE_RIDGE_FADE =     35  --how large a distance to fade the mountains on around the boundary


	------------------------------------------------------------------------------------------------------
	-- Utility functions
	------------------------------------------------------------------------------------------------------
	--is a coord in the bounds? ( x elemof [1,GenerateOptions.width], z elemof [1,GenerateOptions.length] )
	local function InBound(x, z)
		return x >= 1 and x <= GenerateOptions.width and
		       z >= 1 and z <= GenerateOptions.length
	end
	local function at(heightMap, x, z)
		if x > GenerateOptions.width  then x = GenerateOptions.width  end
		if x < 1      then x = 1      end
		if z > GenerateOptions.length then z = GenerateOptions.length end
		if z < 1      then z = 1      end
		return heightMap[x][z]
	end

	--local copies of the standard mathematical functions for speed
	local floor =  math.floor
	local ceil =   math.ceil
	local sqrt =   math.sqrt
	local sin =    math.sin
	local cos =    math.cos
	local max =    math.max
	local min =    math.min
	local abs =    math.abs
	local random = math.random

	--curving functions. They are smooth curves that may values in [0,1] -> [0,1] in usefull ways. In 
	--particular they are used to change the distribution of perlin noise to generate more natural hills
	local function quad_curve(n) --slightly S shaped curve, with tangent -> 2 as x -> 0.5
		if n < 0.5 then
			return n*n + 0.5*n
		else
			return -n*n +2.5*n -0.5
		end
	end
	local function root2_curve(n) --S shaped with a vertical tangent as x -> .5
		if n < 0.5 then
			return 0.5-sqrt(0.5^2 - n^2)
		else
			return sqrt(0.5^2 - (1-n)^2)+0.5
		end
	end
	local function sin4_smallbias_curve(n) --Like quad_curve but biased to smaller outputs
		return sin((0.5*3.141592653)*n)^4
	end
	local function sin4_largebias_curve(n) --like quad_curve but biased to larger outputs
		return 1-sin((0.5*3.141592653)*(1-n))^4
	end

	-- main generation functions begin:

	------------------------------------------------------------------------------------------------------
	-- Clear the terrain, readying the game for a new generation.
	------------------------------------------------------------------------------------------------------
	local function ClearTerrain()
		CancelValues.setAmountFunc(0)
		UpdateGenerationProgressMessage("(1/10) Clearing Old Terrain")

		--first, clear the foliage. If we don't clear the foliage the game will crash when clearing the
		--terrain with so many parts colliding with it. We can just destroy it as it will be generated
		--again when the code needs it, we haven't stored a reference to it yet here.
		GetTreeModel():Destroy()
		wait()

		--now we clear the terrain. With the new terrain, a naked :Clear() call will work performantly enough
		--to use over clearing in slices.
		terrain:Clear()
	end	


	------------------------------------------------------------------------------------------------------
	-- Make the base layer, a hieghtmap that is relatively flat hills and valleys covering the
	-- whole map.
	-- Returns: A GenerateOptions.widthxGenerateOptions.length table heightmop representing the base of the map.
	------------------------------------------------------------------------------------------------------
	local function MakeBaseLayer()
		CancelValues.setAmountFunc(0)
		UpdateGenerationProgressMessage("(2/10) Generating Base Layer")
		--first, get all of the perlin maps that we need
		local mod = 1/GenerateOptions.hillSizeModifier
		local BaseLayer =     PerlinNoiseMap(70*mod)
		--
		local IsPlainsMap =   PerlinNoiseMap(80*mod) --where should the area be flatter?
		local MedFreqHills =  PerlinNoiseMap(28*mod)
		local HighFreqHills = PerlinNoiseMap(14*mod)
		local SmallNoiseMap = PerlinNoiseMap( 4*mod)
		local Quantity =      PerlinNoiseMap(60*mod) --how sparse or dense areas of hills should be
		local IsCrags =       PerlinNoiseMap(100*mod)
		local CragsMap =      PerlinNoiseMap(30*mod)
		--
		local baseLayer = {}
		for x = 1, GenerateOptions.width do
			CancelValues.setAmountFunc(x/GenerateOptions.width)
			pause()
			if CancelValues.cancelActions then return end
			baseLayer[x] = {}
			for z = 1, GenerateOptions.length do
				--------
				-- I hope this is readable enough.... that's the best that I can do. Rest assured, it's
				-- doing a whole pile of fiddling with perlin noise. The general strategy uses 3 parts:
				-- 1) A Base Layer -     Just typical perlin noise scaled by some amount.
				--
				-- 2) A Mask Layer -     Determines where the base layer should show up, through 
				--                       multiplication with the base layer.
				--
				-- 3) A Freqency Layer - The mask layer is also raised to a power. The higher the power,
				--                       The more sparsely distributed the feature will be.
				--
				local quant = Quantity[x][z]
				local hf = quad_curve( HighFreqHills[x][z] )
				local mf = quad_curve( MedFreqHills[x][z]  )
				--
				baseLayer[x][z] =   quad_curve(BaseLayer[x][z])*8
				                  + max( 
				                      85* CragsMap[x][z]^(2.5+  0  ) * max(0, IsCrags[x][z]-0.3    ),
				                      12*             mf^(1.5+quant) * min(1, IsPlainsMap[x][z]+0.5)
				                    )
				                  + 6* hf^(2.0+quant) *IsPlainsMap[x][z]
				                  + GenerateOptions.baseHeight 
				                  + SmallNoiseMap[x][z]*0.9
				--------
			end
		end
		return baseLayer
	end


	------------------------------------------------------------------------------------------------------
	-- A function which carves small cliff faces into the map.
	-- These small cliff faces give the map the appearance that water has been flowing through it, in
	-- contrast to just having the hilly terrain that raw noise will give you.
	-- The cliffs are made by choosing "cleaving planes", and shearing the nearby terrain above and below 
	-- it away from it.
	------------------------------------------------------------------------------------------------------
	local function ApplyCliffs(baseLayer)
		CancelValues.setAmountFunc(0)
		UpdateGenerationProgressMessage("(3/10) Eroding Cliffs")

		-- are cliffs enabled?
		if not GenerateOptions.enableCliffs then return end

		--First get a noise map of how cliffey different areas of the map are. This gives some variation
		--rather than just having all parts of the map have cliffs on them.
		local CliffMap = PerlinNoiseMap(70)

		-- generate an inermediary hight map to store changes to the map as a result of applying cliffs.
		-- this is important because we want to clamp the maximum effect that cliffs can have on the map 
		-- to something around +/-5. Which is most efficiently done with another hight map.
		local cliffs = {}
		for x = 1, GenerateOptions.width do
			cliffs[x] = {}
			for z = 1, GenerateOptions.length do
				cliffs[x][z] = 0 --for summing, initialize to 0 
			end
		end

		--Now, we need to apply the cliffs in two phases. For every cliff we first see exactly what kind
		--of feature it would create, and then if it creates a "good" one go through again and actually
		--apply it to the heightmap. For example, if a cliff ends up being a "pothole", that is, a really
		--small circular dent, then discard it.
		--It turns out that the fastest way to do things is just guessing cliffs and seeing which ones
		--end up good, rather than using a more complex approach.

		--generate a good number of cliffs. 1 cliff / 2000 studs^2 turns out to be best
		local cliffsToGenerate = math.floor(GenerateOptions.width*GenerateOptions.length*CLIFFS_PER_SQ*GenerateOptions.cliffDensityModifier)
		for CliffNum = 1, cliffsToGenerate do 
			pause()
			CancelValues.setAmountFunc(CliffNum/cliffsToGenerate)
			pause()
			if CancelValues.cancelActions then return end
			--
			--first, generate the stats of this cliff
			local x, z = random(2,GenerateOptions.width-1), random(2,GenerateOptions.length-1) --random position
			local radius = random(20,50)                       --random radius of effect
			local amplitude = random(4,9)                      --random amplitude the +/- of heigh generated

			--TODO: We can improve this function by finding the "normal" of the terrain surface and 
			--      putting the cleaving plane deliberately more perpendicular to it, but this is
			--      quite hard to do well in the general case.
			-- --get the average "normal" of the surface in question
			-- for dx = -radius,radius do
			-- 	for dz = -radius,radius do
			-- 		local xp,zp = x+dx,z+dz
			-- 		local r_2 = dx*dx + dz*dz
			-- 		--
			-- 		if (r_2 < radius*radius) then
			-- 			-- 
			-- 		end
			-- 	end
			-- end			

			--the plane to make the "cut" at. We generate a normal and then solve for the plane at the
			--position chosen and with that normal. That plane is then used to find the height of the cut
			--at each affected cell.
			local cliffAtElevation = baseLayer[x][z]
			local norm = Vector3.new(random()*0.5-0.25,1,random()*0.5-0.25).unit
			local planeA, planeB, planeC = norm.x,norm.y,norm.z
			local planeD = -(planeA*x + planeB*cliffAtElevation + planeC*z) 
			local function elevationAt(x,z)
				return -(planeA*x + planeC*z + planeD)/planeB
			end

			--first, check for potholes (and other bad features that you may want to).
			--we do this by counting the number of squares pushed up and number pushed down. This may
			--seem odd but it is a good fast hueristic. Generally petholes occurr when less than 20%
			--of the squares are pushed down.
			--if we hit exactly on a straight line we would expect 50%-50%, and most good features are in
			--the 25%-75% range. 
			local upCount, downCount = 0,0
			for dx = -radius,radius do
				for dz = -radius,radius do
					local xp,zp = x+dx,z+dz
					local r_2 = dx*dx + dz*dz
					--
					if (r_2 < radius*radius) and InBound(xp,zp) then
						local avrHeight = (at(baseLayer,xp+1,zp  ) + at(baseLayer,xp-1,zp  ) + 
						                   at(baseLayer,xp  ,zp  ) +
						                   at(baseLayer,xp  ,zp+1) + at(baseLayer,xp,  zp-1))/5
						if avrHeight > cliffAtElevation then
							upCount = upCount+1
						else
							downCount = downCount+1
						end
					end
				end
			end

			--now, if we aren't in that bad 20% on either end, apply the changes to the heightmap
			if downCount/(upCount+downCount) > 0.2 and upCount/(upCount+downCount) > 0.2 then
				for dx = -radius,radius do
					for dz = -radius,radius do
						local xp,zp = x+dx,z+dz
						local r = sqrt(dx*dx + dz*dz)
						--
						--for every square which in-bounds square in the range of the effect
						if (r < radius) and InBound(xp,zp) then
							--find the average hieght at this square, and compare it to the 
							local avrHeight = (at(baseLayer,xp+1,zp  ) + at(baseLayer,xp-1,zp  ) + 
							                   at(baseLayer,xp  ,zp  ) +
							                   at(baseLayer,xp  ,zp+1) + at(baseLayer,xp,  zp-1))/5
							local nearnessToCenter = sin4_smallbias_curve((radius-r)/radius)
							local cliffiness = quad_curve(CliffMap[xp][zp])
							if avrHeight > elevationAt(xp,zp) then
								cliffs[xp][zp] = cliffs[xp][zp] + nearnessToCenter*amplitude*cliffiness
							else
								cliffs[xp][zp] = cliffs[xp][zp] - nearnessToCenter*amplitude*cliffiness
							end
						end
					end
				end			
			end
		end

		--now, apply all of the changes stored in the cliffs map to the baseLayer, clamping the
		--cliffs value to +/- 4 in the process.
		for x = 1, GenerateOptions.width do
			for z = 1, GenerateOptions.length do
				local v = cliffs[x][z]
				if v >  4 then v =  4 end
				if v < -4 then v = -4 end
				baseLayer[x][z] = baseLayer[x][z] + v
			end
		end
	end	


	------------------------------------------------------------------------------------------------------
	-- Next we have to generate a high mountain layer to separate the two sides of the combat.
	-- Rather than using some heavily built up recursive noise, only a couple layers of noise are used,
	-- this gives the effect of valleys between the peaks, that let players find a nice strategic path
	-- to get to the other side of the map or prevent the opponents from as a part of the gameplay.
	--
	-- Returns: MountainMask, MountainHeight
	------------------------------------------------------------------------------------------------------
	function ApplyMountains(baseLayer)
		CancelValues.setAmountFunc(0)
		UpdateGenerationProgressMessage("(4/10) Building Mountain Layer")

		-- first off, a sanity check: check that the mountain height is higher than the base layer.
		-- If not it doesn't make sense to place any mountains.
		-- Also do this if there are no mountains requested
		if GenerateOptions.mountainHeight <= GenerateOptions.baseHeight or GenerateOptions.mountainMode == "None" then
			-- just return no mountains
			local mountains = {}
			local mask = {}
			for x = 1, GenerateOptions.width do
				mountains[x] = {}
				mask[x] = {}
				for z = 1, GenerateOptions.length do
					mountains[x][z] = 0
					mask[x][z] = 0
				end
			end
			return mask, mountains
		end

		local minDimension = math.min(GenerateOptions.width, GenerateOptions.length)

		--first, we need the noise for the mountain layer itself
		local SteepMountains =   PerlinNoiseMap( minDimension*GenerateOptions.mountainSize*0.9 ) --40)
		local ShallowMountains = PerlinNoiseMap( minDimension*GenerateOptions.mountainSize*1.1 ) --50)
		local SwitchMap =        PerlinNoiseMap( minDimension*GenerateOptions.mountainSize*1.7 ) --90) --which of steep or shallow to use
		local MountainDetailA =  PerlinNoiseMap( 2.5 )
		local MountainDetailB =  PerlinNoiseMap( 5 )
		local MountainDetailC =  PerlinNoiseMap( 12 )
		local MountainHighDetailShow = PerlinNoiseMap( 20 )

		--
		-- now we need to generate the mountain "mask", which is where the mountains will be shown
		-- down the center of the map.
		local mountainMask = {}
		if GenerateOptions.mountainMode == "Ridge" then
			-- Ridge mode, generates a ridge of mountains down the middle of the map
			-- We sort of need two copies of this code, as depending which dimension of the terrain
			-- is larger, we need to change the orientation of the ridge, but this is not easy.
			if GenerateOptions.width < GenerateOptions.length then
				local RidgeWidthMap = PerlinNoiseMap(GenerateOptions.length/4) -- was 60
				for x = 1, GenerateOptions.width do
					CancelValues.setAmountFunc(x / GenerateOptions.width)
					pause()
					if CancelValues.cancelActions then return end
					mountainMask[x] = {}
					local radius = ceil(MIDDLE_RIDGE_RADIUS + MIDDLE_RIDGE_VARIANCE*RidgeWidthMap[x][1])
					local center = floor(GenerateOptions.length/2)
					--lead up to 
					for z = 1, GenerateOptions.length do
						local distToCenter = abs(center-z)
						if distToCenter < radius - MIDDLE_RIDGE_FADE then
							mountainMask[x][z] = 1
						elseif distToCenter < radius + MIDDLE_RIDGE_FADE then
							mountainMask[x][z] = 
								((radius+MIDDLE_RIDGE_FADE)-distToCenter) / (MIDDLE_RIDGE_FADE*2)
						else
							mountainMask[x][z] = 0
						end 
					end
				end
			else
				local RidgeWidthMap = PerlinNoiseMap(GenerateOptions.width/4)
				for x = 1, GenerateOptions.width do
					mountainMask[x] = {}
				end
				for z = 1, GenerateOptions.length do
					CancelValues.setAmountFunc(z / GenerateOptions.length)
					pause()
					if CancelValues.cancelActions then return end
					local radius = ceil(MIDDLE_RIDGE_RADIUS + MIDDLE_RIDGE_VARIANCE*RidgeWidthMap[z][1])
					local center = floor(GenerateOptions.width/2)
					--lead up to 
					for x = 1, GenerateOptions.width do
						local distToCenter = abs(center-x)
						if distToCenter < radius - MIDDLE_RIDGE_FADE then
							mountainMask[x][z] = 1
						elseif distToCenter < radius + MIDDLE_RIDGE_FADE then
							mountainMask[x][z] = 
								((radius+MIDDLE_RIDGE_FADE)-distToCenter) / (MIDDLE_RIDGE_FADE*2)
						else
							mountainMask[x][z] = 0
						end 
					end
				end
			end

		elseif GenerateOptions.mountainMode == "Ring" then
			-- quite similar to the ridge mode, however, the ridge is around the edge of the terrain
			-- rather than running down the middle.
			local RingWidthMap = PerlinNoiseMap(minDimension/4)
			for x = 1, GenerateOptions.width do
				mountainMask[x] = {}
				CancelValues.setAmountFunc(x / GenerateOptions.width)
				pause()
				if CancelValues.cancelActions then return end
				for z = 1, GenerateOptions.length do
					-- we need to find the distance to the nearest edge
					local distToEdge = math.min(GenerateOptions.width - MIDDLE_RIDGE_RADIUS - RingWidthMap[GenerateOptions.width][z]*MIDDLE_RIDGE_VARIANCE - x,
						                        x - MIDDLE_RIDGE_RADIUS - RingWidthMap[1][z]*MIDDLE_RIDGE_VARIANCE,
						                        GenerateOptions.length - MIDDLE_RIDGE_RADIUS - RingWidthMap[x][GenerateOptions.length]*MIDDLE_RIDGE_VARIANCE - z,
						                        z - MIDDLE_RIDGE_RADIUS - RingWidthMap[x][1]*MIDDLE_RIDGE_VARIANCE)
					if distToEdge > MIDDLE_RIDGE_FADE then
						mountainMask[x][z] = 0
					elseif distToEdge > 0 then
						mountainMask[x][z] = 1 - (distToEdge / MIDDLE_RIDGE_FADE)
					else
						mountainMask[x][z] = 1
					end
				end
			end

		elseif GenerateOptions.mountainMode == "Whole Map" then
			-- whole map mode, mountains make up the whole map
			-- just fill the mask with 1s
			for x = 1, GenerateOptions.width do
				mountainMask[x] = {}
				for z = 1, GenerateOptions.length do
					mountainMask[x][z] = 1
				end
			end	

		elseif GenerateOptions.mountainMode == "Random" then
			-- random mode, place mountains randomly around the map
			-- the mask is just a perlin noise map
			mountainMask = PerlinNoiseMap(minDimension*GenerateOptions.mountainSize)
			for x = 1, GenerateOptions.width do
				for z = 1, GenerateOptions.length do
					mountainMask[x][z] = (mountainMask[x][z]*2 - 1)^3 / 2 + 0.5
				end
			end

		elseif GenerateOptions.mountainMode == "Interactive" then
			-- interactive mode: TODO user fills in exactly where they want mountains.
			--local xc = x-floor(GenerateOptions.width/2) + GenerateOptions.xpos
			--local zc = z-floor(GenerateOptions.length/2) + GenerateOptions.zpos
			local minx, minz = -floor(GenerateOptions.width/2) + GenerateOptions.xpos, -floor(GenerateOptions.length/2) + GenerateOptions.zpos
			local maxx, maxz =  floor(GenerateOptions.width/2) + GenerateOptions.xpos,  floor(GenerateOptions.length/2) + GenerateOptions.zpos

			-- draw the canvas for the user to draw on
			--local region = Region3int16.new(Vector3int16.new(minx, 0, minz), Vector3int16.new(maxx, 0, maxz))
			local region = Region3.new(Vector3.new(minx, -4, minz)*4, Vector3.new(maxx, 0, maxz)*4)
			terrain:FillRegion(region, 4, Enum.Material.Sand)

			-- events to handle the tool being otherwise used or progress being cancelled
			local orEvent = Instance.new("BindableEvent")
			local deactivatingC = deactivatingEvent.Event:connect(function() orEvent:Fire({Type = "Deactivated"}) end)
			local cancelC = CancelValues.bindForCancel.Event:connect(function() orEvent:Fire({Type = "Canceled"}) end)

			-- activate the plugin temporarily to get the mouse
			--plugin:Activate(true)
			--local mouse = plugin:GetMouse()

			local messageBox = RbxGui.CreateMessageDialog("Interactive Mode", "Draw where you want mountains to be located in the level.\n"..
				                                                              "Click and drag to draw.\n"..
				                                                              "Hold down shift to erase instead.", 
			                                              {{Text = "Done", Function = function()
			                                              	orEvent:Fire({Type = "ClickDone"})
			                                              end}})
			messageBox.Parent = MainScreenGui
			messageBox:TweenSizeAndPosition(UDim2.new(0, 320, 0, 170), UDim2.new(0, 10, 0, 10), 'Out', 'Quad', 2)

			-- initialize the terrain map
			for x = 1, GenerateOptions.width do
				mountainMask[x] = {}
				for z = 1, GenerateOptions.length do
					mountainMask[x][z] = false
				end
			end

			-- set up the mouse
			local mouseDown = false
			local shiftHeld = false
			local function doPaint()
				if mouse.Target and mouse.Target:IsA('Terrain') then
					local cell = mouse.Target:WorldToCellPreferSolid(mouse.Hit.p)

					-- do a paint. Note: We paint into the mountain mask with true/false rather than 0/1 in order
					-- to make the AA algorithm that we apply to the results faster.
					for dx = -10, 10 do
						for dz = -10, 10 do
							local x, z = cell.x + dx, cell.z + dz
							local datax, dataz = x - minx + 1, z - minz + 1
							if x >= minx and x <= maxx and z >= minz and z <= maxz and dx*dx + dz*dz < 10*10 then
								if shiftHeld then
									--terrain:SetCell(x, 0, z, 5, 0, 0) -- asphalt
									terrain:FillRegion(
										Region3.new(Vector3.new(x*4, -4, z*4), Vector3.new((x+1)*4, 0, (z+1)*4)),
										4,
										Enum.Material.Sand)
									mountainMask[datax][dataz] = false
								else
									--terrain:SetCell(x, 0, z, 16, 0, 0) --blue plastic
									terrain:FillRegion(
										Region3.new(Vector3.new(x*4, -4, z*4), Vector3.new((x+1)*4, 0, (z+1)*4)),
										4,
										Enum.Material.Rock)
									mountainMask[datax][dataz] = true
								end
							end
						end
					end
				end
			end
			mouseC1=nil
			mouseC2=nil
			mouseC3=nil
			mouseC4=nil
			mouseC5=nil
			if mouse then
				mouseC1 = mouse.Button1Down:connect(function()
					mouseDown = true
					doPaint()
				end)
				mouseC2 = mouse.Button1Up:connect(function()
					mouseDown = false
				end)
				mouseC3 = mouse.Move:connect(function()
					if mouseDown then
						doPaint()
					end
				end)
				mouseC4 = mouse.KeyDown:connect(function(key)
					if string.byte(key) == 48 then -- shift key = 48, for both right and left shift
						shiftHeld = true
					end
				end)
				mouseC5 = mouse.KeyUp:connect(function(key)
					if string.byte(key) == 48 then -- shift key = 48, for both right and left shift
						shiftHeld = false
					end
				end)
			end

			-- wait for the user to be done
			local hresult = orEvent.Event:wait()

			-- disconnect all of the events that we made
			deactivatingC:disconnect()
			cancelC:disconnect()
			if mouseC1 then
				mouseC1:disconnect()
				mouseC2:disconnect()
				mouseC3:disconnect()
				mouseC4:disconnect()
				mouseC5:disconnect()
			end

			-- kill the message box
			messageBox:Destroy()

			-- get rid of the canvas
			terrain:FillRegion(region, 4, Enum.Material.Air)

			-- depending on why they are done, do stuff
			local AA_SIZE = 8
			if hresult.Type == "ClickDone" then
				local newMask = {}

				UpdateGenerationProgressMessage("(4/10) Antialiasing selection")

				-- cache some stuff into locals for a faster runtime
				local _w, _l = GenerateOptions.width, GenerateOptions.length

				-- generate a bucket map so that we can easily find what areas need to be anti-aliased
				local bucketMap = {} -- [][] = 0 => ground, 1 => mountain, 2 => both
				local bwidth = math.ceil(_w/AA_SIZE)
				local blength = math.ceil(_l/AA_SIZE)
				for bx = 1, bwidth do
					bucketMap[bx] = {}
					for bz = 1, blength do
						bucketMap[bx][bz] = false
					end
				end
				for bx = 1, bwidth do
					CancelValues.setAmountFunc(bx / bwidth * 0.5)
					pause()
					for bz = 1, blength do
						local foundMountain = false
						local foundGround = false
						for x = (bx-1)*AA_SIZE + 1, math.min(bx*AA_SIZE, _w) do
							for z = (bz-1)*AA_SIZE + 1, math.min(bz*AA_SIZE, _l) do
								if mountainMask[x][z] then
									foundMountain = true
								else
									foundGround = true
								end
							end
						end
						if foundGround and foundMountain then
							-- this and all adjancent buckets need anti aliasing
							for dx = -1, 1 do
								for dz = -1, 1 do
									local xc, zc = bx+dx, bz+dz
									if xc > 0 and zc > 0 and xc <= bwidth and zc <= blength then
										bucketMap[xc][zc] = true
									end
								end
							end
						end
					end
				end

				for x = 1, _w do
					newMask[x] = {}
					for z = 1, _l do
						newMask[x][z] = mountainMask[x][z] and 1 or 0
					end
				end

				-- now, for each bucket, if it needs AA, then we AA all of the cells within it
				for bx = 1, bwidth do
					CancelValues.setAmountFunc(bx / bwidth * 0.5 + 0.5)
					pause()
					for bz = 1, blength do
						if bucketMap[bx][bz] then
							for x = (bx-1)*AA_SIZE + 1, math.min(bx*AA_SIZE, GenerateOptions.width) do
								for z = (bz-1)*AA_SIZE + 1, math.min(bz*AA_SIZE, GenerateOptions.length) do
									local count, total = 0, 0
									for dx = -AA_SIZE,AA_SIZE do
										for dz = -AA_SIZE,AA_SIZE do
											local xc, zc = x + dx, z + dz
											if xc <= _w and xc > 0 and zc > 0 and zc <= _l then
												total = total + (mountainMask[xc][zc] and 1 or 0)
												count = count + 1
											end
										end
									end	
									newMask[x][z] = total / count								
								end
							end
						end
					end
				end			

				mountainMask = newMask

			elseif hresult.Type == "Deactivated" or hresult.Type == "Canceled" then
				-- return an empty mask
				for x = 1, GenerateOptions.width do
					for z = 1, GenerateOptions.length do
						mountainMask[x][z] = 0
					end
				end
				return mountainMask, SteepMountains

			else
				assert("unreachable")
			end

		-- none is handled at the start of the function
		else
			assert("unreachable")
		end

		--now, using the mountainMap weighted average between the mountain values and the base values
		--once we've done that we have to scale them up to make maximum usage of our available vertical
		--space. The highest peok should be at exactly y=amplitude specified by the user
		--We reuse the SteepMountains array as a place to write the results out to before we do a
		--seoond round scaling them up.
		local maxValue = 0
		local minValue = math.huge
		for x = 1, GenerateOptions.width do
			if CancelValues.cancelActions then return end
			for z = 1, GenerateOptions.length do
				local steepFrac =   SwitchMap[x][z]
				local shallowFrac = 1-steepFrac
				--
				local mountainHeight =   steepFrac  *sin4_smallbias_curve(SteepMountains[x][z])
				                       + shallowFrac*ShallowMountains[x][z]
				if mountainHeight > maxValue then maxValue = mountainHeight end
				if mountainHeight < minValue then minValue = mountainHeight end
				SteepMountains[x][z] = mountainHeight
			end
		end
		local usedFrac = (maxValue-minValue) / (GenerateOptions.mountainHeight-GenerateOptions.baseHeight) --1 less or else we get cut off without doing an extra floor()

		--now, scale and add the mountain layer to the baseLayer. We can do both of these steps in the
		--same loop. This time we will re-use the SteepMountain layer as the total scaled mountain layer
		--to.
		--here we apply the mountain frequency option from the options.
		for x = 1, GenerateOptions.width do
			if CancelValues.cancelActions then return end
			for z = 1, GenerateOptions.length do 
				local mountainLayer = GenerateOptions.baseHeight + (SteepMountains[x][z]-minValue)*(1/usedFrac)
				mountainLayer = 
					mountainLayer 
					- 6*MountainDetailB[x][z]
					+ 5*MountainDetailC[x][z]
				local highDetailShow = MountainHighDetailShow[x][z] 
				local highDetailFrac;
				if highDetailShow > 0.25 and highDetailShow < 0.75 then
					highDetailFrac = 1
				else
					highDetailFrac = (math.abs(highDetailShow - 0.5)-0.25) / 0.25
				end
				mountainLayer = mountainLayer + highDetailFrac*4*MountainDetailA[x][z]
				SteepMountains[x][z] = mountainLayer
				local mask = mountainMask[x][z]*GenerateOptions.mountainFrequency -- TODO: What's the problem here??
				baseLayer[x][z] =  (1-mask)*baseLayer[x][z]
				                  +(  mask)*mountainLayer
			end
		end

		--return the values
		return mountainMask, SteepMountains
	end


	------------------------------------------------------------------------------------------------------
	-- There may be some holes left over, fill them.
	-- Any areas which are <= 0 in the base layer we're building are holes, and should be changed to
	-- a value of 1
	------------------------------------------------------------------------------------------------------
	local function FillHoles(baseLayer)
		UpdateGenerationProgressMessage("(5/10) Filling Holes")
		for x = 1, GenerateOptions.width do
			CancelValues.setAmountFunc(x / GenerateOptions.width)
			pause()
			if CancelValues.cancelActions then return end
			for z = 1, GenerateOptions.length do
				if baseLayer[x][z] < 2 then
					baseLayer[x][z] = 2
				end
			end
		end
	end


	------------------------------------------------------------------------------------------------------
	-- Now that the heightmap is fully constructed, coloring.
	-- All of the coloring is done as post-process using only various hightmaps from previous phases. The
	-- advantage of this is that it is easy to change the look and feel of the map when adding new
	-- features, as opposed to if a persistent coloring state were maintained as the heigh-map is
	-- build up, where you would have to worry about ovecdraw from following phases.
	-- It also turns out to be faster to do it this way. It is qutie tricky to decide how to color in
	-- phases based on what previous and furture phases do, as opposed to in a single coloring pass here.
	--
	-- Returns: A map of CellMaterial codes, or special color codes, that can be used in drawing out the
	--          heightmap to the terrain.
	------------------------------------------------------------------------------------------------------
	local function ColorMap(baseLayer, mountainMask, mountainMap)
		UpdateGenerationProgressMessage("(6/10) Coloring Map")
		--first, make a map that we will use to decide where to put sand, and where to put grass
		local SandMapA = PerlinNoiseMap(100)
		local SandMapB = PerlinNoiseMap(50)
		local SandMapC = PerlinNoiseMap(25)

		-- Flecks
		local FlecksMapA = PerlinNoiseMap(40)
		local FlecksMapB = PerlinNoiseMap(25)
		local FlecksMapC = PerlinNoiseMap(15)

		--the map to write the colors out to
		local ColorMap = {}

		--now, we do a single pass over every square in the map, and color it
		if GenerateOptions.colorMode == "Auto Color" then
			for x = 1, GenerateOptions.width do
				CancelValues.setAmountFunc(x / GenerateOptions.width)
				pause()
				if CancelValues.cancelActions then return end
				ColorMap[x] = {}
				pause()
				for z = 1, GenerateOptions.length do
					--first, weneed to find all the heights of all of the nearby squares, so we can calculate
					--both an average height at this location, and a total variance at this location.
					local _1,_2,_3,_4,_5,_6,_7,_8,_9 =
						at(baseLayer,x+1,z+1),
						at(baseLayer,x+1,z  ),
						at(baseLayer,x+1,z-1),
						at(baseLayer,x  ,z+1),
						at(baseLayer,x  ,z  ),
						at(baseLayer,x  ,z-1),
						at(baseLayer,x-1,z+1),
						at(baseLayer,x-1,z  ),
						at(baseLayer,x-1,z-1)
					local h = _5
					local avr = (_1+_2+_3+_4+_5+_6+_7+_8+_9)/9
					local tot = (abs(_1-avr) + abs(_2-avr) + abs(_3-avr) + 
					             abs(_4-avr) + abs(_5-avr) + abs(_6-avr) + 
					             abs(_7-avr) + abs(_8-avr) + abs(_9-avr))

					--now, using those values, color the map.
					if abs(h-avr) > 1 and GenerateOptions.colorCliffs then
						--~~if the average is far from the height then we are in a sharp slope region. We give
						--these areas a special color code so that where they are drawn they will not just
						--be single color columns like the rest, which would lead to vertical striping~~
						-- **REMOVED**, disabled until smooth terrain gets more materials to work with
						ColorMap[x][z] = Enum.Material.Rock
					else
						local mountainHeight = mountainMask[x][z]*mountainMap[x][z]*GenerateOptions.mountainFrequency
						local sandy = SandMapA[x][z]+SandMapB[x][z]+SandMapC[x][z]
						if not GenerateOptions.addSandyRegions then
							sandy = 0
						end
						--
						if tot>5 or (sandy > 1.5 and mountainHeight > 40) then
							if tot<5 then
								--we are are really high up, place snow here
								if GenerateOptions.snowtoppedMountains then
									ColorMap[x][z] = snowMaterial--Rock --snowey: TODO: Needs new material under smooth terrain
								else
									if GenerateOptions.colorMountains then
										ColorMap[x][z] = Enum.Material.Rock
									else
										ColorMap[x][z] = Enum.Material.Slate--Grass
									end
								end
							else
								--we are in a steep area in the mountains, but not a really steep area
								--reuse the sandy map for a bit of variation in the mountain material
								if GenerateOptions.colorMountains then
									if sandy > 1.5 then
										ColorMap[x][z] = Enum.Material.Sand--Enum.Material.Rock
									else
										ColorMap[x][z] = Enum.Material.Rock
									end
								else
									ColorMap[x][z] = Enum.Material.Slate
								end
							end
						elseif mountainHeight > 30 then
							--it's both not steep, and high in the mountains. These areas are snow-covered
							--peaks, color them snowey
							if GenerateOptions.snowtoppedMountains then
								ColorMap[x][z] = snowMaterial -- todo: Should be snowey once material arrives
							else
								if GenerateOptions.colorMountains then
									ColorMap[x][z] = Enum.Material.Rock
								else
									ColorMap[x][z] = Enum.Material.Grass
								end
							end
						else
							--it's a smooth area. Decide whether to place sand or grass. Sand should only be
							--placed in concave areas which are not in the mountains:
							--        (not in mountains)             (concave)     (not too high either)
							if (sandy*(1-mountainMask[x][z])>1.5) and (h<=avr) and (baseLayer[x][z] < 15) then
								ColorMap[x][z] = Enum.Material.Sand --sand
							else
								ColorMap[x][z] = Enum.Material.Grass --grass
							end
						end
					end

					-- If the color would be grass, apply flecks
					if ColorMap[x][z] == Enum.Material.Grass then
						local flecks = 0.4*FlecksMapA[x][z] + 0.3*FlecksMapB[x][z] + 0.3*FlecksMapC[x][z]
						if flecks < math.random()*0.55 then
							ColorMap[x][z] = Enum.Material.Rock
						end
					end
				end
			end
		elseif GenerateOptions.colorMode == "Solid Color" then
			for x = 1, GenerateOptions.width do
				ColorMap[x] = {}
				for z = 1, GenerateOptions.length do
					ColorMap[x][z] = Enum.Material.Grass
				end
			end		
		end

		--done, return the color map
		return ColorMap
	end


	--Day 1
		--This is Luke, looking though Stravant's code. I've been able to ctrl+f to find some points of interest, but
		--I have to lay down cable as I go so that I do not get lost. This system looks pretty large. Not sure if I
		--have enough cable to explore it all.
	--Day 2
		--The system goes much deeper than I initially thought. Much of the interface actually leads to the RbxGui
		--library and is impassable. I am looking into alternatives.
	--Day 3
		--Every once in a while I find strange markings. I think someone else has been here before me.
	--Day 4
		--My hands are very dirty and I have nothing to clean them off with.
	--Day 5
		--There is much more that I need to do and my time is running short. I am not sure if I had allocated enough
		--time to make it out alive. If you are reading this, tell me family that I love them.


	------------------------------------------------------------------------------------------------------
	-- Now, we actually draw out the level to the Terrain instance.
	------------------------------------------------------------------------------------------------------
	local SharpColors = {4,11,12,13}
	local function DrawTerrain(baseLayer, colormap)
		CancelValues.setAmountFunc(0)
		UpdateGenerationProgressMessage("(7/10) Drawing Terrain")
		--
		-- Occupancy and material arrays
		local materialVoxels = {}
		local occupancyVoxels = {}
		local globalMaxHeight = 0
		--
		for x = 1, GenerateOptions.width do 
			materialVoxels[x] = {}
			occupancyVoxels[x] = {}
			--
			CancelValues.setAmountFunc(x/GenerateOptions.width)
			pause()
			if CancelValues.cancelActions then return end
			for z = 1, GenerateOptions.length do 
				--
				local color = colormap[x][z]
				local y = baseLayer[x][z]
				local xc = x-floor(GenerateOptions.width/2) + GenerateOptions.xpos
				local zc = z-floor(GenerateOptions.length/2) + GenerateOptions.zpos
				--
				local columnHeight = ceil(y)
				globalMaxHeight = math.max(globalMaxHeight, columnHeight)

				-- Occupancy array
				for yc = 1, columnHeight do
					if not occupancyVoxels[x][yc] then
						occupancyVoxels[x][yc] = {}
					end
					occupancyVoxels[x][yc][z] = 1
				end
				occupancyVoxels[x][columnHeight][z] = 1 - (columnHeight - y)
				
				-- Material array
				for yc = 1, columnHeight do
					if not materialVoxels[x][yc] then
						materialVoxels[x][yc] = {}
					end
					if (columnHeight - yc) < GenerateOptions.soilDepth then
						materialVoxels[x][yc][z] = color
					else
						materialVoxels[x][yc][z] = Enum.Material.Rock
					end
				end
			end 
		end

		-- Fill in and extra Y entries
		--print("Gen with size:", GenerateOptions.width, globalMaxHeight, GenerateOptions.length)
		for x = 1, GenerateOptions.width do 
			for y = 1, globalMaxHeight do
				if not materialVoxels[x][y] then
					materialVoxels[x][y] = {}
				end
				if not occupancyVoxels[x][y] then
					occupancyVoxels[x][y] = {}
				end
				for z = 1, GenerateOptions.length do
					if not materialVoxels[x][y][z] then
						materialVoxels[x][y][z] = Enum.Material.Air
					end
					if not occupancyVoxels[x][y][z] then
						occupancyVoxels[x][y][z] = 0
					end
				end
			end
		end

		-- Do main draw (writing out the hieghtmap data & colors to the Roblox terrain)
		local width = GenerateOptions.width
		local length = GenerateOptions.length
		local xbase = -floor(width/2) + GenerateOptions.xpos
		local zbase = -floor(length/2) + GenerateOptions.zpos
		
		-- Chunk in chucks of 10
		local CHUNK_SIZE = 20
		local chunkCount = ceil(width / CHUNK_SIZE)
		for chunkNum = 1, chunkCount - 1 do
			-- Calculate the chunk data
			local chunkMaterials = {}
			local chunkOccupancies = {}
			for i = 1, CHUNK_SIZE do
				chunkMaterials[i]   = materialVoxels[(chunkNum-1)*CHUNK_SIZE + i]
				chunkOccupancies[i] = occupancyVoxels[(chunkNum-1)*CHUNK_SIZE + i]
			end

			-- Calculate the chunk region
			local chunkRegion = Region3.new(
				Vector3.new(xbase + (chunkNum-1)*CHUNK_SIZE, 0,               zbase         )*4,
				Vector3.new(xbase + (chunkNum  )*CHUNK_SIZE, globalMaxHeight, zbase + length)*4
			)

			-- Draw the chunk
			terrain:WriteVoxels(chunkRegion, 4, chunkMaterials, chunkOccupancies)
			wait(0.5)
		end

		-- Final chunk, which may have an odd size
		do
			local finalChunkSize = width - (chunkCount-1)*CHUNK_SIZE

			-- Calculate the final chunk data
			local chunkMaterials = {}
			local chunkOccupancies = {}
			for i = 1, finalChunkSize do
				chunkMaterials[i]   = materialVoxels[(chunkCount-1)*finalChunkSize + i]
				chunkOccupancies[i] = occupancyVoxels[(chunkCount-1)*finalChunkSize + i]
			end

			-- Calculate the final chunk region
			local chunkRegion = Region3.new(
				Vector3.new(xbase + (chunkCount-1)*finalChunkSize, 0,               zbase         )*4,
				Vector3.new(xbase + (chunkCount  )*finalChunkSize, globalMaxHeight, zbase + length)*4
			)

			-- Draw the final chunk
			terrain:WriteVoxels(chunkRegion, 4, chunkMaterials, chunkOccupancies)
		end

		-- Non-chunked code
		-- local drawRegion = 	
		-- 	Region3.new(
		-- 		Vector3.new(xbase,       0,               zbase       )*4,
		-- 		Vector3.new(xbase+width, globalMaxHeight, zbase+length)*4)
		-- --print("Region:", drawRegion)
		-- terrain:WriteVoxels(
		-- 	drawRegion,
		-- 	4,
		-- 	materialVoxels,
		-- 	occupancyVoxels)
	end


	------------------------------------------------------------------------------------------------------
	-- Next we draw lakes into the map.
	-- The lake drawing process finds local minima in the map, and then flood-fills them to as
	-- high a level as it can without the flood-fill spilling into a very large area. This seems
	-- inefficient but it actually does not take that much time to fill a reasonable number of local
	-- minima using this approach.
	-- We need to take the base mask as a parameter so that we ensure the lake fills do not spill into
	-- the areas reserved for the bases.
	--
	-- Returns: A mask of where water was placed
	------------------------------------------------------------------------------------------------------
	local Directions = {{1,0,1},         {-1,0,1},       {0,1,1},        {0,-1,1},
                    {-1,-1,sqrt(2)}, {-1,1,sqrt(2)}, {1,-1,sqrt(2)}, {1,1,sqrt(2)}}
	local function PlaceLakes(baseLayer)
		CancelValues.setAmountFunc(0)
		UpdateGenerationProgressMessage("(8/10) Filling Lakes")
		wait()

		--first generate the water mask
		local waterMask = {}
		for x = 1, GenerateOptions.width do
			waterMask[x] = {}
			for z = 1, GenerateOptions.length do 
				waterMask[x][z] = 0
			end
		end

		-- generate lakes
		if GenerateOptions.waterMode == "Lakes" or GenerateOptions.waterMode == "Both" then
			--generate a certain density of lakes
			for i = 1, GenerateOptions.width*GenerateOptions.length*GenerateOptions.lakesPerSquare do
				CancelValues.setAmountFunc(i / GenerateOptions.width*GenerateOptions.length*GenerateOptions.lakesPerSquare * 0.5)
				pause()
				if CancelValues.cancelActions then return end

				--select a random position
				local x,z = random(1,GenerateOptions.width), random(1,GenerateOptions.length)

				--now, we need to find the local minimum nearest to this position
				local prevdx,prevdz;
				while true do
					--see if we will drop down in any of the directions
					local leastDir, leastChange = nil,100
					local h = baseLayer[x][z]
					for _, dir in pairs(Directions) do 
						local nx,nz = x+dir[1],z+dir[2]
						if InBound(nx,nz) then
							local hn = baseLayer[nx][nz]
							if hn < h and abs(hn-h) < leastChange then
								leastDir = dir
								leastChange = abs(hn-h)
							end
						end
					end
					if not leastDir then
						break
					end
					x = x + leastDir[1]
					z = z + leastDir[2]
					if leastChange == 0 then
						break
					end
				end

				--(x,z) is now the local min nearest the random location. If there is not already a
				--water-feature there then try to generate one.
				if waterMask[x][z] == 0 then
					--now, in order to get the deepest possible lake, we try to generate one at sereval
					--heights, starting with the deepest. Doing anywhere from 1 deep to 3 deep works nicely.
					for y = floor(baseLayer[x][z])+5, floor(baseLayer[x][z])+1, -1 do
						pause()
						--we need to make a temporary map to store this attpmt's changes in, rather than
						--just applying them right to the water mask.
						local tmpWaterMask = {}
						for x = 1, GenerateOptions.width do
							tmpWaterMask[x] = {}
							for z = 1, GenerateOptions.length do
								tmpWaterMask[x][z] = waterMask[x][z]
							end
						end

						--now do a flood-fill
						local filledCount = 0
						local function FloodFill(x,z)
							if not InBound(x,z) then return true end

							if tmpWaterMask[x][z] == 0 or y > tmpWaterMask[x][z] then
								if y > floor(baseLayer[x][z]) then
									--place water here
									tmpWaterMask[x][z] = y
									filledCount = filledCount+1
									--
									if filledCount > GenerateOptions.lakeMaxSize then
										--bail out early, don't flood bases
										return false
									end
									--
									if not FloodFill(x-1,z  ) then return false end
									if not FloodFill(x+1,z  ) then return false end
									if not FloodFill(x  ,z-1) then return false end
									if not FloodFill(x  ,z+1) then return false end
								else
									--flag as tested
									tmpWaterMask[x][z] = -1
								end
							end

							return true
						end
						if FloodFill(x,z) then
							--we found a good lake, now add it to the waterMask (we can do this with just
							--assignment because we were editing a copy of the old water mask)
							waterMask = tmpWaterMask
							break			
						end
					end
				end
			end
		end

		-- generate the ocean
		if GenerateOptions.waterMode == "Ocean" or GenerateOptions.waterMode == "Both" then
			local depth = GenerateOptions.sealevel
			for x = 1, GenerateOptions.width do
				for z = 1, GenerateOptions.length do
					if waterMask[x][z] < depth then
						waterMask[x][z] = depth
					end
				end
			end
		end

		--now, draw out the water
		for x = 1, GenerateOptions.width do 
			CancelValues.setAmountFunc(x / GenerateOptions.width * 0.5 + 0.5)
			pause()
			if CancelValues.cancelActions then return end
			for z = 1, GenerateOptions.length do 
				local tx,tz = floor(x-GenerateOptions.width/2)+GenerateOptions.xpos,
				              floor(z-GenerateOptions.length/2)+GenerateOptions.zpos
				pause()
				for y = floor(baseLayer[x][z])+1, waterMask[x][z] do
					terrain:SetWaterCell(tx-1,y-1,tz-1,0,0)
				end
			end
		end

		--and return the waterMask
		return waterMask
	end


	------------------------------------------------------------------------------------------------------
	-- Next we smooth the terrain. 
	-- Now that both the main terrain and water are placed, we smooth things.
	------------------------------------------------------------------------------------------------------
	local function SmoothTerrain()
		-- Terrain smoothing, obsolete for smooth terrain
		-- CancelValues.setAmountFunc(0)
		-- UpdateGenerationProgressMessage("(9/10) Smoothing Terrain")
		-- wait()
		-- terrain:AutowedgeCells(terrain.MaxExtents)
	end


	------------------------------------------------------------------------------------------------------
	-- Finally we draw trees to the surface.
	-- We generate a noise treemap, and then trees are placed:
	--   In grassy areas
	--   Which are not covered in water
	------------------------------------------------------------------------------------------------------
	local function DrawTrees(baseLayer, waterMask, colormap)
		CancelValues.setAmountFunc(0)
		UpdateGenerationProgressMessage("(10/10) Drawing Trees")
		wait()

		-- if the is no vegetation, then stop right away
		if not GenerateOptions.vegetationMode then return end

		local Base = Instance.new("Part")
		Base.Name = "Trunk"
		Base.formFactor = "Custom"
		Base.TopSurface = 0
		Base.BottomSurface = 0
		Base.Anchored = false
		Base.BrickColor = BrickColor.new("Reddish brown")
		local Leaves = Base:Clone()
		Leaves.Name = "Leaves"
		Leaves.CanCollide = false
		Leaves.Anchored = false
		Leaves.BrickColor = BrickColor.new("Dark green")
		local leafmesh = Instance.new("SpecialMesh")
		leafmesh.MeshType = "FileMesh"
		leafmesh.MeshId = "http://www.roblox.com/asset/?id=1290033"
		leafmesh.TextureId = "http://www.roblox.com/asset/?id=2861779" 
		leafmesh.Parent = Leaves
		local basemesh = Instance.new("SpecialMesh",Base)
		basemesh.MeshType = "Head"
		local leaf_mult = {
			Vector3.new(1.5,1.5,1.2);
			Vector3.new(1.5,1,  1.5);
			Vector3.new(1.2,1.5,1.5);
			Vector3.new(1.5,1.5,1.5);
		}
		local function dot(c1,c2)
			local m = CFrame.Angles(math.pi/2,0,0)
			return (c1*m).lookVector:Dot((c2*m).lookVector)
		end
		local function weldit(a,b,cf)
			b.CFrame=a.CFrame*cf
			local w=Instance.new("Weld")
			w.Part0=a
			w.Part1=b
			w.C0=cf
			w.Parent=a
		end
		local function Branch(base,c)
			if c <= 0 then
				local leaves = Leaves:Clone()
				local vol = base.Size.x+base.Size.y+base.Size.z
				leaves.Mesh.Scale = leaf_mult[math.random(1,#leaf_mult)]*math.random(vol/3*10,vol/3*12)/10
				leaves.Size = leaves.Mesh.Scale*0.75
				weldit(base,leaves,CFrame.new(0,base.Size.y/2,0))
				leaves.Parent = base.Parent
			else
				local pos = base.CFrame*CFrame.new(0,base.Size/2,0)
				local height = base.Size.y
				local width = base.Size.x
				local nb = math.random(2,2) 
				local r = math.random(45,135) 
				local da = math.random(20+55/c,40+40/c)
				local ba = math.random(-da/3,da/3)
				for i=0,nb-1 do
					local branch = base:Clone()
					branch.Name = "Branch"
					local h = height*math.random(95,115)/100 
					local new = CFrame.new(0,height/2,0) * CFrame.Angles(0,0,math.rad(ba))
					new = new * CFrame.Angles(0,i*(math.pi*2/nb)+r,math.rad(da/2)) * CFrame.new(0,h/2,0)
					local w = dot(new,branch.CFrame)*width*0.9
					branch.Size = Vector3.new(w,h,w)
					weldit(base,branch,new)
					branch.Parent = base.Parent
					Branch(branch,c-1)
				end
			end
		end
		local function GenerateTree(location,complexity,width,height)
			local tree = Instance.new("Model")
			tree.Name = "Tree"
			tree.Parent = GetTreeModel()
			local foundation=Instance.new("Part")
			foundation.Name="Foundation"
			foundation.Anchored=true
			foundation.CanCollide=false
			foundation.formFactor="Custom"
			foundation.Size=Vector3.new(.2,.2,.2)
			foundation.CFrame=CFrame.new(location)
			foundation.Parent=tree
			local base = Base:Clone()
			base.Parent = tree
			base.Size = Vector3.new(width,height,width)
			basecf = CFrame.new(0,height/2,0)*CFrame.Angles(0,math.rad(math.random(1,360)),0)
			weldit(foundation,base,basecf)
			Branch(base,complexity)
			return tree
		end
		------------------------------------------------------------------------
		local TreeMapA = PerlinNoiseMap(200)
		local TreeMapB = PerlinNoiseMap(100)
		--
		for i = 1, GenerateOptions.width*GenerateOptions.length*GenerateOptions.vegetationDensity do --1 tree / ~100 blocks^2
			local x,z = random(4,GenerateOptions.width-4),random(4,GenerateOptions.length-4)
			local treeDensity = TreeMapA[x][z]+TreeMapB[x][z]
			--
			if treeDensity > 1.1 and colormap[x][z] == 1 and waterMask[x][z] <= 0 then
				pause()
				local tree_at_h = baseLayer[x][z]
				local tx,tz = floor(x-GenerateOptions.width/2)+GenerateOptions.xpos, 
				              floor(z-GenerateOptions.length/2)+GenerateOptions.zpos
				local tree_at = terrain:CellCenterToWorld(tx, tree_at_h, tz)
				GenerateTree(tree_at, random(1,random(1,2)), random(4,7), random(11,18))
			end
		end
	end


	------------------------------------------------------------------------------------------------------
	-- And finally call on all of the generation code
	------------------------------------------------------------------------------------------------------
	UpdateGenerationProgressMessage("Generating Terrain")
	wait(0.3)
	do
		                                  ClearTerrain()
		                                  if CancelValues.cancelActions then On(); return UnloadProgressBar() end
		                                  wait(0.3)
		local baseLayer =                 MakeBaseLayer()
		                                  if CancelValues.cancelActions then On(); return UnloadProgressBar() end
		                                  wait(0.3)
		                                  ApplyCliffs(baseLayer)
		                                  if CancelValues.cancelActions then On(); return UnloadProgressBar() end
		                                  wait(0.3)
		local mountainMask, mountainMap = ApplyMountains(baseLayer)
		                                  if CancelValues.cancelActions then On(); return UnloadProgressBar() end
		                                  wait(0.3)
		                                  FillHoles(baseLayer)
		                                  if CancelValues.cancelActions then On(); return UnloadProgressBar() end
		                                  wait(0.3)
		local colormap =                  ColorMap(baseLayer, mountainMask, mountainMap)
		                                  if CancelValues.cancelActions then On(); return UnloadProgressBar() end
		                                  wait(0.3)
		                                  DrawTerrain(baseLayer, colormap)
		                                  if CancelValues.cancelActions then On(); return UnloadProgressBar() end
		                                  wait(0.3)
		local waterMask =                 PlaceLakes(baseLayer)
		                                  if CancelValues.cancelActions then On(); return UnloadProgressBar() end
		                                  wait(0.3)
		                                  SmoothTerrain()
		                                  if CancelValues.cancelActions then On(); return UnloadProgressBar() end
		                                  wait(0.3)
		                                  DrawTrees(baseLayer, waterMask, colormap)
		                                  if CancelValues.cancelActions then On(); return UnloadProgressBar() end
	end
	UpdateGenerationProgressMessage("Finishing Generation")
	wait(0.3)

	-- Clean up the progress bar.
	UnloadProgressBar()

	--Generate Terrain End
	game:GetService("ChangeHistoryService"):SetWaypoint("Generate")

	--Turn on the plugin again
	On()
end

-- Clears all terrain.
function ClearTerrain()
	--toolbarbutton:SetActive(false)
	Off()
	
	--Erase Terrain
	terrain:Clear()
	
	--Erase Terrain End
	UnloadProgressBar()
	game:GetService("ChangeHistoryService"):SetWaypoint("Reset")
end


--==========================================================================================================--
--                                       Main Plugin GUI Setup                                            ==--
--==========================================================================================================--

--screengui
MainScreenGui = Instance.new("ScreenGui", game:GetService("CoreGui"))
MainScreenGui.Name = 'TerrainCreatorGui'

-- Gui frame for the plugin.
--local terrainPropertiesDragBar, terrainFrame, terrainHelpFrame, terrainCloseEvent = RbxGui.CreatePluginFrame("Terrain Generator",UDim2.new(0,186,0,487),UDim2.new(0,0,0,0),false,MainScreenGui)
--terrainPropertiesDragBar.Visible = false
--terrainCloseEvent.Event:connect(function()
--	if turnOff then
--		turnOff()
--	end
--	Off()
--end)
--
--terrainHelpFrame.Size = UDim2.new(0,300,0,539)
--
---- Create the help text:
--
--local terrainHelpText = Instance.new("TextLabel",terrainHelpFrame)
--terrainHelpText.Name = "HelpText"
--terrainHelpText.Font = Enum.Font.ArialBold
--terrainHelpText.FontSize = Enum.FontSize.Size12
--terrainHelpText.TextColor3 = Color3.new(227/255,227/255,227/255)
--terrainHelpText.TextXAlignment = Enum.TextXAlignment.Left
--terrainHelpText.TextYAlignment = Enum.TextYAlignment.Top
--terrainHelpText.Position = UDim2.new(0,4,0,4)
--terrainHelpText.Size = UDim2.new(1,-8,0,132)
--terrainHelpText.BackgroundTransparency = 1
--terrainHelpText.TextWrap = true
--terrainHelpText.Text = [[                         <> Generate Terrain <>
--================= Basic Options =================
-- - Width: Terrain size in the X direction.
-- - Length: Terrain size in the Z direction.
-- - Base Height: The lowest point that will be present in
--     the terrain.
--================== Hill Options =================
-- - Hill Density: A smaller value gives fewer, smoother 
--     hills, while a larger value gives more sharp 
--     frequent hills.
-- - Enable Cliffs: If enabled, cliffs will be sliced into
--]]
--
--local helpSecondText = terrainHelpText:clone()
--helpSecondText.Name = "HelpSecondText"
--helpSecondText.Position = UDim2.new(0,0,1,0)
--helpSecondText.Size = UDim2.new(1,0,0,157)
--helpSecondText.Text = [[     random locations on the map.
-- - Cliff Density: If cliffs are enabled, the larger the
--     value the more cliffs will be added to the map.
--================ Mountain Options ==============
-- - Region Dropdown: Mountains can be placed in one 
--     of several different regions around the map, or 
--     placed in a custom region of your choice by using 
--     the "Interactive" mode.
-- - Max Mountain Height: The maximum elevation that
--     mountains placed in the region will reach.
-- - Mountainous %: How mountainous is the chosen 
--     region? 100% = place only mountains there,
--     0% = place only hills there.
--]]
--helpSecondText.Parent = terrainHelpText
--
--local helpThirdText = helpSecondText:clone()
--helpThirdText.Name = "HelpThirdText"
--helpThirdText.Position = UDim2.new(0,0,1,0)
--helpThirdText.Size = UDim2.new(1,0,0,157)
--helpThirdText.Text = [[ - Mountain Size: How wide are the mountains to be, 
--     in terms of the width of the whole map?
--================== Water Options ===============
-- - Water Dropdown: A sea level can be chosen to fill
--     the whole level to, or lakes can be placed around
--     the level, or both.
-- - Lake Density: How many lakes to place in the level?
-- - Lake max size: How large should the lakes be?
-- - Sea level: What water-level to fill the level up to?
--================ Material Options ===============
-- - Material Dropdown: Select to either color the level
--    one solid color, or automatically color it based on 
--    the landscape and some settings.
--]]
--helpThirdText.Parent = helpSecondText
--
--local helpFourthText = helpThirdText:clone()
--helpFourthText.Name = "HelpFourthText"
--helpFourthText.Position = UDim2.new(0,0,1,0)
--helpFourthText.Size = UDim2.new(1,0,0,120)
--helpFourthText.Text = [[ - Color Mountains: Color steep slopes and high 
--    places with a grey color?
-- - Snow on Mountaintops: Color the tops of high 
--    mountains with a white color?
-- - Color Cliffs: Color sharp cliffs with a grey color?
-- - Add Sandy Regions: Color some low, flat areas with
--    a yellow color?
--]]
--helpFourthText.Parent = helpThirdText

newguiFrame:WaitForChild('CloseButton').MouseButton1Down:connect(function()
	if turnOff then
		turnOff()
	end
	Off()
end)

--==========================================================================================================--
--                            Population of the GUI with all the setting controlls                        ==--
--==========================================================================================================--

-- small  utility to easily change the position of GUI elements while still having them
-- relatively positioned.
local curY = 10
local function setY(v) curY = v end
local function addY(v) curY = curY + v end

-- Slider for controlling the width of the terran area.  Terran is created in a region this wide.
widthLabel = CreateStandardLabel("WidthLabel", UDim2.new(0, 8, 0, curY), UDim2.new(0, 67, 0, 14), "", canvasFrame)
addY(16)
widthSliderGui, widthSliderPosition = CreateStandardSlider('WidthSliderGui', UDim2.new(0,1,0,curY), UDim2.new(0,10,0.5,-2), 512-31, 
																	function(widthSliderPosition) 
																		TerrainOptions.width = widthSliderPosition.Value+31
																		widthLabel.Text = "Width: "..TerrainOptions.width
																	end, nil, canvasFrame)
addY(25)
widthSliderPosition.Value = TerrainOptions.width-31

-- Slider for controlling the length of the terran area.  Terran is created in a region this long.
lengthLabel = CreateStandardLabel("LengthLabel", UDim2.new(0, 8, 0, curY), UDim2.new(0, 67, 0, 14), "", canvasFrame)
addY(16)
lengthSliderGui, lengthSliderPosition = CreateStandardSlider('LengthSliderGui', UDim2.new(0,1,0,curY), UDim2.new(0,10,0.5,-2), 512-31, 
																	function(lengthSliderPosition) 
																		TerrainOptions.length = lengthSliderPosition.Value+31
																		lengthLabel.Text = "Length: "..TerrainOptions.length
																	end, nil, canvasFrame)
addY(25)
lengthSliderPosition.Value = TerrainOptions.length-31


-- Slider for controlling the baseHeight, how deep the base terrain should be.
--[[baseHeightLabel = CreateStandardLabel("BaseHeightLabel", UDim2.new(0, 8, 0, curY), UDim2.new(0, 67, 0, 14), "", canvasFrame)
addY(16)
baseHeightSliderGui, baseHeightSliderPosition = CreateStandardSlider('BaseHeightSliderGui', UDim2.new(0,1,0,curY), UDim2.new(0,10,0.5,-2), game.Workspace.Terrain.MaxExtents.Max.Y, 
																	function(baseHeightSliderPosition) 
																		TerrainOptions.baseHeight = baseHeightSliderPosition.Value - 1
																		baseHeightLabel.Text = "Base Height: ".. (TerrainOptions.baseHeight)
																	end, nil, canvasFrame)
addY(25)
baseHeightSliderPosition.Value = TerrainOptions.baseHeight]]
local accordionBoxAtY = curY


-----------------------
-- hill settings
hillSettingsButton, hillSettingsFrame = createSection('Hills', 105, 122, canvasFrame)--Instance.new("Frame")

-- hill size slider
hillDensityLabel = CreateStandardLabel("DensityLabel", UDim2.new(0, 8, 0, 5), UDim2.new(0, 67, 0, 14), "", hillSettingsFrame)
hillDensitySliderGui, hillDensitySliderPosition = CreateStandardSlider('DensitySliderGui', UDim2.new(0,1,0,21), UDim2.new(0,10,0.5,-2), 21, 
																	function(hillDensitySliderPosition) 
																		TerrainOptions.hillSizeModifier = 2^((hillDensitySliderPosition.Value - 11)/10)
																		hillDensityLabel.Text = "Hill roughness: "..tostring(math.floor(TerrainOptions.hillSizeModifier*100))..'%'
																	end, nil, hillSettingsFrame)
hillDensitySliderPosition.Value = math.log(TerrainOptions.hillSizeModifier)/math.log(2)*10 + 11

-- cliffs modifier
--[[function onEnableCliffs()
	TerrainOptions.enableCliffs = not TerrainOptions.enableCliffs
	if TerrainOptions.enableCliffs then
		enableCliffsCheckbox.Text = "X"
		cliffDensitySliderGui.Visible = true
		cliffDensityLabel.Visible = true
	else
		enableCliffsCheckbox.Text = ""
		cliffDensitySliderGui.Visible = false
		cliffDensityLabel.Visible = false
	end
end
enableCliffsLabel = CreateStandardLabel("EnableCliffsLabel", UDim2.new(0, 44, 0, 46), UDim2.new(0, 50, 0, 24), "Enable Cliffs", hillSettingsFrame)
enableCliffsCheckbox = CreateStandardButton("EnableCliffsCheckbox", UDim2.new(0, 10, 0, 46), '', 
	                                           onEnableCliffs, hillSettingsFrame, UDim2.new(0, 24, 0, 24))]]
createCheckBox('Enable Cliffs', 46, hillSettingsFrame, TerrainOptions.enableCliffs, function(newSetting)
	TerrainOptions.enableCliffs = newSetting
end)

cliffDensityLabel = CreateStandardLabel("CliffDensityLabel", UDim2.new(0, 8, 0, 78), UDim2.new(0, 67, 0, 14), "", hillSettingsFrame)
cliffDensitySliderGui, cliffDensitySliderPosition = CreateStandardSlider('CliffDensitySliderGui', UDim2.new(0,1,0,94), UDim2.new(0,10,0.5,-2), 21, 
																	function(cliffDensitySliderPosition) 
																		TerrainOptions.cliffDensityModifier = 2^((cliffDensitySliderPosition.Value - 11)/10)
																		cliffDensityLabel.Text = "Cliffs: "..tostring(math.floor(TerrainOptions.cliffDensityModifier*100))..'%'
																	end, nil, hillSettingsFrame)
cliffDensitySliderPosition.Value = math.log(TerrainOptions.cliffDensityModifier)/math.log(2)*10 + 11

--onEnableCliffs()	--Why is this here twice?
--onEnableCliffs()



-----------------------
-- mountain settings
mountainSettingsButton, mountainSettingsFrame = createSection('Mountains', 257, 207, canvasFrame)--Frame = Instance.new('Frame')

function onMountainPatternDropdown(value) 
	TerrainOptions.mountainMode = value
	for _, o in pairs(mountainControlSet) do
		o.Visible = (value ~= "None")
	end
	if value == "None" then
		mountainPatternDescriptionLabel.Text = "(No mountains)"
	elseif value == "Whole Map" then
		mountainPatternDescriptionLabel.Text = "(The entire map contains mountains)"
	elseif value == "Ridge" then
		mountainPatternDescriptionLabel.Text = "(One ridge of mountains down the middle of the map)"
	elseif value == "Ring" then
		mountainPatternDescriptionLabel.Text = "(Edges of map contain mountains, with hills in the middle)"
	elseif value == "Random" then
		mountainPatternDescriptionLabel.Text = "(Mountains are randomly placed around the map)"
	elseif value == "Interactive" then
		mountainPatternDescriptionLabel.Text = "(Draw a custom region where you want mountains to be located)"
	end
end
mountainPatternDropdown, mountainPatternSet = CreateStandardDropdown("MountainPatternDropdown",
						        UDim2.new(0,0,0,5),
								{"None", "Whole Map", "Ridge", "Ring", "Random", "Interactive"},
								"Ridge",
								onMountainPatternDropdown, 
								mountainSettingsFrame)

mountainPatternDescriptionLabel = CreateStandardLabel("DescriptionLabel", UDim2.new(0, 10, 0, 34), UDim2.new(1, -10, 0, 44), "", mountainSettingsFrame)
mountainPatternDescriptionLabel.Font = "Arial"
mountainPatternDescriptionLabel.TextWrap = true
mountainPatternDescriptionLabel.TextYAlignment = "Top"

mountainAmplitudeLabel = CreateStandardLabel("AmplitudeLabel", UDim2.new(0, 8, 0, 81), UDim2.new(0, 67, 0, 14), "", mountainSettingsFrame)
mountainAmplitudeSliderGui, mountainAmplitudeSliderPosition = CreateStandardSlider('AmplitudeSliderGui', UDim2.new(0,1,0,97), UDim2.new(0,10,0.5,-2), 62, 
																	function(mountainAmplitudeSliderPosition) 
																		TerrainOptions.mountainHeight = mountainAmplitudeSliderPosition.Value + 1
																		mountainAmplitudeLabel.Text = "Max mountain height: "..TerrainOptions.mountainHeight
																	end, nil, mountainSettingsFrame)
mountainAmplitudeSliderPosition.Value = TerrainOptions.mountainHeight

mountainFrequencyLabel = CreateStandardLabel("FrequencyLabel", UDim2.new(0, 8, 0, 122), UDim2.new(0, 67, 0, 14), "", mountainSettingsFrame)
mountainFrequencySlider, mountainFrequencySliderPosition = CreateStandardSlider('FrequencySlider', UDim2.new(0,1,0,138), UDim2.new(0,10,0.5,-2), 11,
	                                                                function(mountainFrequencySliderPosition)
	                                                                	TerrainOptions.mountainFrequency = (mountainFrequencySliderPosition.Value-1)/10
	                                                                	mountainFrequencyLabel.Text = "Region is "..(TerrainOptions.mountainFrequency*100).."% mountainous"
	                                                                end, nil, mountainSettingsFrame)
mountainFrequencySliderPosition.Value = TerrainOptions.mountainFrequency*10 + 1

mountainFeatureSizeLabel = CreateStandardLabel("FeatureSizeLabel", UDim2.new(0, 8, 0, 163), UDim2.new(0, 67, 0, 14), "", mountainSettingsFrame)
mountainFeatureSizeSlider, mountainFeatureSizeSliderPosition = CreateStandardSlider('FeatureSizeSlider', UDim2.new(0,1,0,179), UDim2.new(0,10,0.5,-2), 41,
	                                                                function(mountainFeatureSizeSliderPosition)
	                                                                	TerrainOptions.mountainSize = (mountainFeatureSizeSliderPosition.Value-1)/40
	                                                                	mountainFeatureSizeLabel.Text = 
	                                                                		"Mountain Width: "..(TerrainOptions.mountainSize*100).."% of map"
	                                                                end, nil, mountainSettingsFrame)
mountainFeatureSizeSliderPosition.Value = TerrainOptions.mountainSize*40 + 1

mountainControlSet = {mountainAmplitudeLabel, mountainAmplitudeSliderGui, mountainFrequencyLabel, mountainFrequencySlider,
                      mountainFeatureSizeLabel, mountainFeatureSizeSlider}
onMountainPatternDropdown("Ridge")


-----------------------
-- water settings
waterSettingsButton, waterSettingsFrame = createSection('Water', 494, 136, canvasFrame)--Frame = Instance.new('Frame')

-- water mode dropdown
--[[function onSetWaterMode(value)
	TerrainOptions.waterMode = value
	--
	if value == "None" then
		sealevelLabel.Visible = false
		sealevelSliderGui.Visible = false
	end
	if value == "Lakes" or value == "Both" then
		lakeDensityLabel.Visible = true
		lakeDensitySliderGui.Visible = true
		lakeMaxSizeLabel.Visible = true
		lakeMaxSizeSliderGui.Visible = true
		lakeDensityLabel.Position = UDim2.new(0, 8, 0, 34)
		lakeDensitySliderGui.Position = UDim2.new(0, 0, 0, 50)
		lakeMaxSizeLabel.Position = UDim2.new(0, 8, 0, 75)
		lakeMaxSizeSliderGui.Position = UDim2.new(0, 0, 0, 91)
	else
		lakeDensityLabel.Visible = false
		lakeDensitySliderGui.Visible = false
		lakeMaxSizeLabel.Visible = false
		lakeMaxSizeSliderGui.Visible = false
	end
	if value == "Ocean" then
		sealevelLabel.Visible = true
		sealevelSliderGui.Visible = true
		sealevelLabel.Position = UDim2.new(0, 8, 0, 34)
		sealevelSliderGui.Position = UDim2.new(0, 0, 0, 50)
	elseif value == "Both" then
		sealevelLabel.Visible = true
		sealevelSliderGui.Visible = true
		sealevelLabel.Position = UDim2.new(0, 8, 0, 116)
		sealevelSliderGui.Position = UDim2.new(0, 0, 0, 132)
	else
		sealevelLabel.Visible = false
		sealevelSliderGui.Visible = false
	end
end
waterModeDropdown, waterModeSet = CreateStandardDropdown("WaterModeDropdown",
                                                         UDim2.new(0,0,0,0),
                                                         {"None", "Lakes", "Ocean", "Both"},
                                                         "None",
                                                         onSetWaterMode,
                                                         waterSettingsFrame)
]]
-- Slider for controlling the waterHeight, how much water to fill.
lakeDensityLabel = CreateStandardLabel("LakeFrequencyLabel", UDim2.new(0, 8, 0, 7), UDim2.new(0, 67, 0, 14), "", waterSettingsFrame)
local lakeDensitySteps = 101
lakeDensitySliderGui, lakeDensitySliderPosition = CreateStandardSlider('LakeFrequencySliderGui', UDim2.new(0,1,0,23), UDim2.new(0,10,0.5,-2), lakeDensitySteps, 
																	function(lakeDensitySliderPosition) 
																		local val = lakeDensitySliderPosition.Value
																		local str, num;
																		--[[if val == 1 then		--This cade was when the lakeDensitySteps variable was set to 4
																			str, num = "No lakes.", 0
																		elseif val == 2 then
																			str, num = "1 lake / 20000 squares", 1/20000
																		elseif val == 3 then
																			str, num = "2 lakes/ 20000 squares", 1/10000
																		elseif val == 4 then
																			str, num = "4 lakes/ 20000 squares", 1/5000
																		end]]
																		local percent=(val-1)/(lakeDensitySteps-1)
																		str = tostring(percent*100)..'%'
																		num = percent<=0 and 0 or 1/(5000*(2^((1-percent)*4)))	--40000*(percent^2)
																		TerrainOptions.lakesPerSquare = num
																		lakeDensityLabel.Text = "Lakes: "..str
																	end, nil, waterSettingsFrame)
lakeDensitySliderPosition.Value = 76

-- Slider for the lake max size
lakeMaxSizeLabel = CreateStandardLabel("LakeMaxSizeLabel", UDim2.new(0, 8, 0, 7), UDim2.new(0, 67, 0, 14), "", waterSettingsFrame)
lakeMaxSizeSliderGui, lakeMaxSizeSliderPosition = CreateStandardSlider('LakeMaxSizeSliderGui', UDim2.new(0,1,0,23), UDim2.new(0,10,0.5,-2), 5, 
																	function(lakeMaxSizeSliderPosition)
																		TerrainOptions.lakeMaxSize = lakeMaxSizeSliderPosition.Value*1000
																		lakeMaxSizeLabel.Text = "Lake max size: "..TerrainOptions.lakeMaxSize--.." squares" --trim
																	end, nil, waterSettingsFrame)
lakeMaxSizeSliderPosition.Value = TerrainOptions.lakeMaxSize/1000

-- Slider for the sea level
sealevelLabel = CreateStandardLabel("SeaLevelLabel", UDim2.new(0, 8, 0, 7), UDim2.new(0, 67, 0, 14), "", waterSettingsFrame)
sealevelSliderGui, sealevelSliderPosition = CreateStandardSlider("SealevelSliderGui", UDim2.new(0,1,0,18), UDim2.new(0,10,0.5,-2), 31,
                                                                 function(sealevelSliderPosition)
                                                                 	TerrainOptions.sealevel = sealevelSliderPosition.Value - 1
                                                                 	sealevelLabel.Text = "Ocean level: "..TerrainOptions.sealevel
                                                                 end, nil, waterSettingsFrame)
sealevelSliderPosition.Value = TerrainOptions.sealevel + 1

--waterModeSet("Lakes")
-- programetrically setting the water mode does not call set callback oddly 
-- enough, so it has to be manually called here to lay things out right.
--onSetWaterMode("Lakes")
TerrainOptions.waterMode = 'Both'
lakeDensityLabel.Visible = true
lakeDensitySliderGui.Visible = true
lakeMaxSizeLabel.Visible = true
lakeMaxSizeSliderGui.Visible = true
lakeDensityLabel.Position = UDim2.new(0, 8, 0, 9)
lakeDensitySliderGui.Position = UDim2.new(0, 0, 0, 25)
lakeMaxSizeLabel.Position = UDim2.new(0, 8, 0, 50)
lakeMaxSizeSliderGui.Position = UDim2.new(0, 0, 0, 66)
sealevelLabel.Visible = true
sealevelSliderGui.Visible = true
sealevelLabel.Position = UDim2.new(0, 8, 0, 91)
sealevelSliderGui.Position = UDim2.new(0, 0, 0, 107)



--------------------------
-- vegetation settings
--[[vegetationSettingsFrame = Instance.new('Frame')

vegetationCheckBox = CreateStandardButton("GenerateButton",
									      UDim2.new(0, 10, 0, 0),
									      '',
									      function()
									      	setVegetationMode(not TerrainOptions.vegetationMode)
									      end,
									      vegetationSettingsFrame,
									      UDim2.new(0, 24, 0, 24))
function setVegetationMode(st)
	TerrainOptions.vegetationMode = st
	if st then
		vegetationCheckBox.Text = "X"
		vegetationSliderGui.Visible = true
		-- get the text to update to what it should be
		onVegetationSlider(vegetationSliderPosition)
	else
		vegetationCheckBox.Text = ""
		vegetationLabel.Text = "Vegetation not enabled"
		vegetationSliderGui.Visible = false
	end
end

function onVegetationSlider(vegetationSliderPosition)
	TerrainOptions.vegetationDensity = vegetationSliderPosition.Value / 200
	local suffix = (vegetationSliderPosition.Value > 1) and "s" or ""
	vegetationLabel.Text = vegetationSliderPosition.Value.." tree"..suffix.." / 200 squares"
end

vegetationLabel = CreateStandardLabel("VegetationLabel", UDim2.new(0, 44, 0, 5), UDim2.new(0, 50, 0, 14), "", vegetationSettingsFrame)
vegetationSliderGui, vegetationSliderPosition = CreateStandardSlider("VegetationSliderGui", UDim2.new(0,1,0,24), UDim2.new(0,10,0.5,-2), 4,
                                                                 onVegetationSlider, nil, vegetationSettingsFrame)
vegetationSliderPosition.Value = TerrainOptions.vegetationDensity * 200
setVegetationMode(TerrainOptions.vegetationMode)]]



--------------------------
-- material settings 
materialSettingsButton, materialSettingsFrame = createSection('Materials', 660, 100, canvasFrame)--Frame = Instance.new('Frame')

--[[function onSetColorMode(value)
	TerrainOptions.colorMode = value
	for _, o in pairs(materialControlSet) do
		o.Visible = (value == "Auto Color")
	end
end
colorModeDropdown, colorModeSet = CreateStandardDropdown("ColorModeDropdown",
                                                         UDim2.new(0,0,0,0),
                                                         {"Solid Color", "Auto Color"},
                                                         "Auto Color",
                                                         onSetColorMode,
                                                         materialSettingsFrame)]]

--[[function onColorMountainsMode()
	TerrainOptions.colorMountains = not TerrainOptions.colorMountains
	if TerrainOptions.colorMountains then
		colorMountainsCheckbox.Text = "X"
	else
		colorMountainsCheckbox.Text = ""
	end
end
colorMountainsLabel = CreateStandardLabel("ColorMountainsLabel", UDim2.new(0, 44, 0, 34), UDim2.new(0, 50, 0, 24), "Color mountains", materialSettingsFrame)
colorMountainsCheckbox = CreateStandardButton("ColorMountainsCheckbox", UDim2.new(0, 10, 0, 34), '', 
	                                           onColorMountainsMode, materialSettingsFrame, UDim2.new(0, 24, 0, 24))]]

createCheckBox('Rock mountains', 8, materialSettingsFrame, TerrainOptions.colorMountains, function(newSetting)
	TerrainOptions.colorMountains = newSetting
end)

--onColorMountainsMode()	--Two again. How odd.
--onColorMountainsMode()

--[[function onSnowtoppedMountainsMode()
	TerrainOptions.snowtoppedMountains = not TerrainOptions.snowtoppedMountains
	if TerrainOptions.snowtoppedMountains then
		snowtoppedMountainsCheckbox.Text = "X"
	else
		snowtoppedMountainsCheckbox.Text = ""
	end
end
snowtoppedMountainsLabel = CreateStandardLabel("SnowtoppedMountainsLabel", UDim2.new(0, 44, 0, 56), UDim2.new(0, 50, 0, 24), "Snow on mountaintops", materialSettingsFrame)
snowtoppedMountainsCheckbox = CreateStandardButton("SnowtoppedMountaisCheckbox", UDim2.new(0, 10, 0, 56), '', 
	                                           onSnowtoppedMountainsMode, materialSettingsFrame, UDim2.new(0, 24, 0, 24))
onSnowtoppedMountainsMode()
onSnowtoppedMountainsMode()]]

createCheckBox('Snowcap Mountains', 38, materialSettingsFrame, TerrainOptions.snowtoppedMountains, function(newSetting)
	TerrainOptions.snowtoppedMountains = newSetting
end)

--[[function onColorCliffsMode()
	TerrainOptions.colorCliffs = not TerrainOptions.colorCliffs
	if TerrainOptions.colorCliffs then
		colorCliffsCheckbox.Text = "X"
	else
		colorCliffsCheckbox.Text = ""
	end
end
colorCliffsLabel = CreateStandardLabel("ColorCliffsLabel", UDim2.new(0, 44, 0, 78), UDim2.new(0, 50, 0, 24), "Color cliffs", materialSettingsFrame)
colorCliffsCheckbox = CreateStandardButton("ColorCliffsCheckbox", UDim2.new(0, 10, 0, 78), '', 
	                                           onColorCliffsMode, materialSettingsFrame, UDim2.new(0, 24, 0, 24))
onColorCliffsMode()
onColorCliffsMode()]]

--[[createCheckBox('Rock cliffs', 68, materialSettingsFrame, TerrainOptions.colorCliffs, function(newSetting)
	TerrainOptions.colorCliffs = newSetting
end)]]

--[[function onAddSandyRegionsMode()
	TerrainOptions.addSandyRegions = not TerrainOptions.addSandyRegions
	if TerrainOptions.addSandyRegions then
		addSandyRegionsCheckbox.Text = "X"
	else
		addSandyRegionsCheckbox.Text = ""
	end
end
addSandyRegionsLabel = CreateStandardLabel("AddSandyRegionsLabel", UDim2.new(0, 44, 0, 100), UDim2.new(0, 50, 0, 24), "Add sandy regions", materialSettingsFrame)
addSandyRegionsCheckbox = CreateStandardButton("AddSandyRegionsCheckbox", UDim2.new(0, 10, 0, 100), '', 
	                                           onAddSandyRegionsMode, materialSettingsFrame, UDim2.new(0, 24, 0, 24))
onAddSandyRegionsMode()
onAddSandyRegionsMode()

materialControlSet = {colorMountainsLabel, colorMountainsCheckbox, snowtoppedMountainsLabel, snowtoppedMountainsCheckbox,
                      colorCliffsLabel,    colorCliffsCheckbox,    addSandyRegionsLabel,     addSandyRegionsCheckbox}]]
createCheckBox('Add sandy regions', 68, materialSettingsFrame, TerrainOptions.addSandyRegions, function(newSetting)
	TerrainOptions.addSandyRegions = newSetting
end)

-----------------------
-- main accordion for all of those settings
--[[mainSettingsAccordion = CreateStandardAccordion("MoreSettingsAccordion", 
                                                UDim2.new(0, 0, 0, accordionBoxAtY), 
                                                UDim2.new(1, 0, 0, 310),
                                                {
                                                	{Name = 'Hills', Gui = hillSettingsFrame, Height = 200};
                                                	{Name = 'Mountains', Gui = mountainSettingsFrame, Height = 200};
                                                	{Name = 'Water', Gui = waterSettingsFrame, Height = 200};
                                                	{Name = 'Materials', Gui = materialSettingsFrame, Height = 200};
                                                	-- Uncomment to enable vegetation generation as an option.
                                                	-- {Name = 'Vegetation', Gui = vegetationSettingsFrame, Height = 200};
                                                }, 
                                                canvasFrame)]]


-- Button to generate terrain using the current settings.
--[[generateButton = CreateStandardButton("GenerateButton",
									   UDim2.new(0.5, 0, 0, 445),
									   'Generate',
									   ConfirmGenerateTerrain,
									   canvasFrame,
									   UDim2.new(0, 100, 0, 40))]]
newguiFrame:WaitForChild('GenerateButton').MouseButton1Down:connect(ConfirmGenerateTerrain)
									   
-- Button to clear terrain using.  All terrain will be removed.
--[[clearButton = CreateStandardButton("ClearButton",
								   UDim2.new(0.5, -100, 0, 445),
								   'Clear',
								   ConfirmClearTerrain,
								   canvasFrame,
								   UDim2.new(0, 100, 0, 40))]]
newguiFrame:WaitForChild('ClearButton').MouseButton1Down:connect(ConfirmClearTerrain)											   
							
--==========================================================================================================--
--                           Final definition of main On/Off functions                                    ==--
--==========================================================================================================--

-- Run when the popup is activated.
function On(mouseHandMeDown,turnOffHandMeDown)
	--plugin:Activate(true)
	--toolbarbutton:SetActive(true)
	--terrainPropertiesDragBar.Visible = true
	newgui.Parent = coreGui
	on = true
	if mouseHandMeDown then
		mouse = mouseHandMeDown
	end
	if turnOffHandMeDown then
		turnOff = turnOffHandMeDown
	end
end

-- Run when the popup is deactivated.
function Off()
	--toolbarbutton:SetActive(false)
	ClearConformation()
	on = false

	-- Hide the popup gui.
	--terrainPropertiesDragBar.Visible = false	
	newgui.Parent = nil
end

-- and we're finally done loading
loaded = true

return {
	['On']=On,
	['Off'] = Off,
}


]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX16F732BBD989476AB08150CC8624F797">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">SmootherModule</string>
				<ProtectedString name="Source"><![CDATA[--


local terrain = game.Workspace.Terrain


local function getCell(list, x, y, z)
	return list and list[x] and list[x][y] and list[x][y][z]
end

local function extendRange(x)		--This is very important. It allows cells to fully diminish or fully fill by lying to the algorithm
	return x * 1.5 - .25
end

function getNeighborOccupanciesFast(list, x, y, z, includeSelf)
	local fullNeighbor = false
	local emptyNeighbor = false
	local neighborOccupancies = includeSelf and extendRange(getCell(list, x, y, z)) or 0
	local totalNeighbors = includeSelf and 1 or 0
	for axis = 1, 3 do
		for offset = -1, 1, 2 do
			local neighbor = nil
			if axis == 1 then
				neighbor = list[x + offset] and list[x + offset][y][z]
			elseif axis == 2 then
				neighbor = list[x][y + offset] and list[x][y + offset][z]
			elseif axis == 3 then
				neighbor = list[x][y][z + offset]
			end
			if neighbor then
				if neighbor >= 1 then
					fullNeighbor = true
				end
				if neighbor <= 0 then
					emptyNeighbor = true
				end
				neighbor = extendRange(neighbor)
				totalNeighbors = totalNeighbors + 1
				neighborOccupancies = neighborOccupancies + neighbor
			end
		end
	end
	return neighborOccupancies / (totalNeighbors > 0 and totalNeighbors or extendRange(getCell(list, x, y, z))), fullNeighbor, emptyNeighbor
end

function getNeighborOccupancies(list, x, y, z, includeSelf, range)
	local fullNeighbor = false
	local emptyNeighbor = false
	local range = range or 1
	local neighborOccupancies = 0
	local totalNeighbors = 0
	local sqrt = math.sqrt
	for ix = -range, range do
		for iy = -range, range do
			for iz = -range, range do
				if includeSelf or not (ix == 0 and iy == 0 and iz == 0) then
					local neighbor = getCell(list, x + ix, y + iy, z + iz)
					if neighbor then
						local distanceScale = 1 - (sqrt(ix * ix + iy * iy + iz * iz) / (range * 2))
						if neighbor >= 1 then
							fullNeighbor = true
						end
						if neighbor <= 0 then
							emptyNeighbor = true
						end
						neighbor = extendRange(neighbor)
						totalNeighbors = totalNeighbors + 1 * distanceScale
						neighborOccupancies = neighborOccupancies + neighbor * distanceScale
					end
				end
			end
		end
	end
	return neighborOccupancies / (totalNeighbors > 0 and totalNeighbors or extendRange(getCell(list, x, y, z))), fullNeighbor, emptyNeighbor
end


function operation(centerPoint, materials, occupancies, resolution, selectionSize, strength, desiredMaterial, brushType, minBounds, maxBounds)
	local region = Region3.new(minBounds, maxBounds)
	local readMaterials, readOccupancies = terrain:ReadVoxels(region, resolution)

	local radius = selectionSize * .5 * resolution

	local materialAir = Enum.Material.Air

	for ix, vx in ipairs(readOccupancies) do
		local cellVectorX = minBounds.x + (ix - .5) * resolution - centerPoint.x

		for iy, vy in pairs(vx) do
			local cellVectorY = minBounds.y + (iy - .5) * resolution - centerPoint.y

			for iz, cellOccupancy in pairs(vy) do
				local cellVectorZ = minBounds.z + (iz - .5) * resolution - centerPoint.z

				local cellMaterial = materials[ix][iy][iz]
				local distance = math.sqrt(cellVectorX * cellVectorX + cellVectorY * cellVectorY + cellVectorZ * cellVectorZ)
	
				local magnitudePercent = 1
				local brushOccupancy = 1
				if brushType == 'Sphere' then
					magnitudePercent = math.cos(math.min(1, distance / (radius + resolution * .5)) * math.pi * .5)
					brushOccupancy = math.max(0, math.min(1, (radius + .5 * resolution - distance) / resolution))
				elseif brushType == 'Box' then
					--leave as default
				end

				if brushOccupancy >= .5 then
					local neighborOccupancies, fullNeighbor, emptyNeighbor = getNeighborOccupancies(readOccupancies, ix, iy, iz, true, 1)
					local difference = (neighborOccupancies - cellOccupancy) * (strength + .1) * .5 * brushOccupancy * magnitudePercent

					if not fullNeighbor and difference > 0 then
						difference = 0
					elseif not emptyNeighbor and difference < 0 then
						difference = 0
					end

					if readMaterials[ix][iy][iz] == materialAir or cellOccupancy <= 0 and difference > 0 then
						materials[ix][iy][iz] = desiredMaterial
					end
					if difference ~= 0 then
						occupancies[ix][iy][iz] = math.max(0, math.min(1, cellOccupancy + difference))
					end
				end
			end
		end
	end
end

return {
	['operation'] = operation
}

]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="ScreenGui" referent="RBXF8CB673780314CA6A2AE2F49B237BD86">
			<Properties>
				<string name="Name">TerrainBrushGui</string>
			</Properties>
			<Item class="Frame" referent="RBXBAE877C0862E4C5EB21D9CFC6C191FB7">
				<Properties>
					<bool name="Active">true</bool>
					<Color3 name="BackgroundColor3">4294967295</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">Frame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>180</XO>
						<YS>0</YS>
						<YO>295</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">6</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextButton" referent="RBX2A59B4C4CA37433A9593FE2C552EC03B">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">4</token>
						<bool name="Modal">false</bool>
						<string name="Name">CloseButton</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-26</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>25</XO>
							<YS>0</YS>
							<YO>25</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text">X</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBXF80F05100F334887818D1DD66582949F">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0.75</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<string name="Name">TitleLabel</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>25</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Terrain Brush</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBXF4976478A3A049D4A3AFDA670DFF9ED3">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<string name="Name">Label1</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>47</XO>
							<YS>0</YS>
							<YO>20</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Size</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX7132EDF5D10C4E6E908362DB2244CE54">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<string name="Name">Label2</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>55</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>47</XO>
							<YS>0</YS>
							<YO>20</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Strength</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX7CD2F572A4BE4D069D624AABFE61D5A7">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<string name="Name">Label3</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>85</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>47</XO>
							<YS>0</YS>
							<YO>20</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Shape</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX0B63BC2D297E45298CCE289D03359F43">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<string name="Name">Label4</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>203</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>60</XO>
							<YS>0</YS>
							<YO>20</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Material</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">0</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX721FBEAB75A349AFACB1FE725319033A">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<bool name="Modal">false</bool>
						<string name="Name">CheckBox2</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>160</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>26</XO>
							<YS>0</YS>
							<YO>26</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">4</token>
						<string name="Text">X</string>
						<Color3 name="TextColor3">4293848814</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
					<Item class="TextLabel" referent="RBXBA752B5B48BC4742BD1D963263B27C06">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294967295</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">5</token>
							<string name="Name">Label</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>25</XO>
								<YS>0.5</YS>
								<YO>-10</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>90</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Snap to Grid</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageButton" referent="RBX90B3C465402B4CE792663578ACA42625">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=225799533</url></Content>
						<Color3 name="ImageColor3">4294967295</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<bool name="Modal">false</bool>
						<string name="Name">ShapeButton1</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>73</XO>
							<YS>0</YS>
							<YO>81</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>32</XO>
							<YS>0</YS>
							<YO>32</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="ImageButton" referent="RBXEA57E8F567EB4BF294D8492E19155BDE">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=225799696</url></Content>
						<Color3 name="ImageColor3">4294967295</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<bool name="Modal">false</bool>
						<string name="Name">ShapeButton2</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>118</XO>
							<YS>0</YS>
							<YO>81</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>32</XO>
							<YS>0</YS>
							<YO>32</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX7CDFD30454764D2EAE8319A53E606B9D">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0.600000024</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<string name="Name">Divider2</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>195</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>2</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
					<Item class="TextLabel" referent="RBX1BE75A3F0BB741ECA06407A2A733A8AB">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294967295</Color3>
							<float name="BackgroundTransparency">0.600000024</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">6</token>
							<string name="Name">SubDivider</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>-1</XO>
								<YS>0</YS>
								<YO>2</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>2</XO>
								<YS>0</YS>
								<YO>30</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
						</Properties>
						<Item class="TextLabel" referent="RBX62AEF0F5DBE64C0EBC28474D1341AD8E">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4286479998</Color3>
								<float name="BackgroundTransparency">0.600000024</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">4</token>
								<token name="FontSize">6</token>
								<string name="Name">Blocker</string>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>81</XO>
									<YS>0</YS>
									<YO>30</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">3</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="TextLabel" referent="RBX8C3BE64DA5254DFB93E5B882B154D16A">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0.600000024</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<string name="Name">Divider1</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>120</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>2</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX6A33E7C856954FEBA352F9F17281FD6A">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<bool name="Modal">false</bool>
						<string name="Name">CheckBox3</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>90</XO>
							<YS>0</YS>
							<YO>200</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>26</XO>
							<YS>0</YS>
							<YO>26</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">4</token>
						<string name="Text">X</string>
						<Color3 name="TextColor3">4293848814</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
					<Item class="TextLabel" referent="RBX52DE800AB0414D978CB3DE7C54D9DDAB">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294967295</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">5</token>
							<string name="Name">Label</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>20</XO>
								<YS>0.5</YS>
								<YO>-10</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>90</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Auto</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX0A16555EA37948F59628D2807E2D9F26">
					<Properties>
						<bool name="Active">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">DoubleBacking</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>-7</XO>
							<YS>0</YS>
							<YO>-7</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>16</XO>
							<YS>1</YS>
							<YO>16</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">6</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBXE3F78BBC49F34FD3BAC8ADAB331C10F0">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<bool name="Modal">false</bool>
						<string name="Name">CheckBox1</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>130</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>26</XO>
							<YS>0</YS>
							<YO>26</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">4</token>
						<string name="Text">X</string>
						<Color3 name="TextColor3">4293848814</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
					<Item class="TextLabel" referent="RBXFCE92DD81A1C4F65960A5142E5A5824E">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294967295</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">5</token>
							<string name="Name">Label</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>25</XO>
								<YS>0.5</YS>
								<YO>-10</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>90</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Plane Lock</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextLabel" referent="RBX53BF32916A99450EB4681EC89CF1D565">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<string name="Name">ToolTip2</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>55</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>47</XO>
							<YS>0</YS>
							<YO>20</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Ctrl + mouse wheel</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0.300000012</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">0</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">3</int>
					</Properties>
					<Item class="TextLabel" referent="RBXDB4991E6C2A04E2F9CF60B2DB729D6C7">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294967295</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">5</token>
							<string name="Name">Shadow</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>47</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Ctrl + mouse wheel</string>
							<Color3 name="TextColor3">4282071867</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0.300000012</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextLabel" referent="RBX7ECAD609344D4EA786B226F76BA1B861">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<string name="Name">ToolTip1</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>47</XO>
							<YS>0</YS>
							<YO>20</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Shift + mouse wheel</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0.300000012</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">0</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">3</int>
					</Properties>
					<Item class="TextLabel" referent="RBX59F4598C719541E8AC545724A026416A">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294967295</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">5</token>
							<string name="Name">Shadow</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>47</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Shift + mouse wheel</string>
							<Color3 name="TextColor3">4282071867</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0.300000012</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXFE876CAA717E4933BB1D8C079B26E9B7">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">RegionEditorModule</string>
				<ProtectedString name="Source"><![CDATA[--Made by Stickmasterluke


--[[todo:
	-fill region (with material, action)
	-optimize resize scaling code more
]]


while not workspace:WaitForChild('Terrain').IsSmooth do
	workspace.Terrain.Changed:wait()
end

local on = false
local setup = false
local currentTool = 'Create'


--[[local toolBar = plugin:CreateToolbar('Smooth Terrain')
regionEditButton = toolBar:CreateButton(
	'Region Edit',	--button title
	'Manipulate regions of smoothterrain.',	--hover text
	'http://www.roblox.com/asset/?id=180084957'	--icon
)
regionEditButton.Click:connect(function()
	if not on then
		if not setup then
			FirstTimeSetUp()
		end
		Selected()
	else
		Deselected()
	end
end)]]


function FirstTimeSetUp()
	setup = true
	local changeHistory = game:GetService('ChangeHistoryService')
	local terrain = game.Workspace.Terrain
	local coreGui = game:GetService('CoreGui')
	local gui = script.Parent:WaitForChild('TerrainRegionGui')
	local guiFrame = gui:WaitForChild('Frame')
	local closeButton = guiFrame:WaitForChild('CloseButton')
	local buttonFillAir = guiFrame:WaitForChild('ButtonFillAir')
	local buttonFillWater = guiFrame:WaitForChild('ButtonFillWater')
	local buttonSelect = guiFrame:WaitForChild('ButtonSelect')
	local buttonMove = guiFrame:WaitForChild('ButtonMove')
	local buttonResize = guiFrame:WaitForChild('ButtonResize')
	local buttonRotate = guiFrame:WaitForChild('ButtonRotate')
	local buttonCopy = guiFrame:WaitForChild('ButtonCopy')
	local buttonPaste = guiFrame:WaitForChild('ButtonPaste')
	local buttonDelete = guiFrame:WaitForChild('ButtonDelete')
	local library = assert(LoadLibrary('RbxGui'))
	--local mouse = plugin:GetMouse()

	----SETTINGS----
	local mode = 'Select'	--Select, Edit
	local tool = 'None'		--None, Resize, Move, Rotate
	local button = 'Select'	--Select, Move, Resize, Rotate
	local fillAir = true
	local fillWater = true
	----------------

	--SUB SETTINGS--
	local resolution = 4			--This is the size of voxels on Roblox. Why is this a variable? ;)
	local textSelectColor = Color3.new(72/255, 145/255, 212/255)
	local white = Color3.new(238/255, 238/255, 238/255)
	local editColor1 = 'Institutional white'
	local editColor2 = 'Light stone grey'
	local rotationInterval = math.pi * .5
	local regionLengthLimit = 125
	----------------

	--Variables--
	local faceToNormal = {
		[Enum.NormalId.Top] = Vector3.new(0, 1, 0),
		[Enum.NormalId.Bottom] = Vector3.new(0, -1, 0),
		[Enum.NormalId.Left] = Vector3.new(-1, 0, 0),
		[Enum.NormalId.Right] = Vector3.new(1, 0, 0),
		[Enum.NormalId.Front] = Vector3.new(0, 0, -1),
		[Enum.NormalId.Back] = Vector3.new(0, 0, 1),
	}
	local undefined=0/0
	local selectionStart = nil
	local selectionEnd = nil
	local selectionPart = nil
	local selectionObject = nil
	local selectionHandles = nil
	local downLoop = nil
	local clickStart = Vector3.new(0, 0, 0)
	local dragVector = nil
	local dragStart = true
	local lockedMaterials, lockedOccupancies = nil, nil
	local lockedRegion = nil
	local behindThis = nil
	local axis = 'X'
	local materialAir = Enum.Material.Air
	local materialWater = Enum.Material.Water
	local floor = math.floor		--Scaling linear resize
	local ceil = math.ceil
	-------------


	function setButton(newButton)
		lockInMap()
		buttonSelect.Style = newButton == 'Select' and Enum.ButtonStyle.RobloxRoundDropdownButton or Enum.ButtonStyle.RobloxRoundDefaultButton
		buttonSelect.TextColor3 = newButton == 'Select' and textSelectColor or white
		buttonMove.Style = newButton == 'Move' and Enum.ButtonStyle.RobloxRoundDropdownButton or Enum.ButtonStyle.RobloxRoundDefaultButton
		buttonMove.TextColor3 = newButton == 'Move' and textSelectColor or white
		buttonResize.Style = newButton == 'Resize' and Enum.ButtonStyle.RobloxRoundDropdownButton or Enum.ButtonStyle.RobloxRoundDefaultButton
		buttonResize.TextColor3 = newButton == 'Resize' and textSelectColor or white
		buttonRotate.Style = newButton == 'Rotate' and Enum.ButtonStyle.RobloxRoundDropdownButton or Enum.ButtonStyle.RobloxRoundDefaultButton
		buttonRotate.TextColor3 = newButton == 'Rotate' and textSelectColor or white
		if newButton == 'Select' then
			mode = 'Select'
			tool = 'Resize'
		elseif newButton == 'Move' then
			mode = 'Edit'
			tool = 'Move'
		elseif newButton == 'Resize' then
			mode = 'Edit'
			tool = 'Resize'
		elseif newButton == 'Rotate' then
			mode = 'Edit'
			tool = 'Rotate'
		end
		button = newButton
		renderSelection()
	end

	buttonSelect.MouseButton1Down:connect(function()
		setButton('Select')
	end)
	buttonMove.MouseButton1Down:connect(function()
		setButton('Move')
	end)
	buttonResize.MouseButton1Down:connect(function()
		setButton('Resize')
	end)
	buttonRotate.MouseButton1Down:connect(function()
		setButton('Rotate')
	end)

	buttonFillAir.MouseButton1Down:connect(function()
		fillAir = not fillAir
		buttonFillAir.Text = fillAir and 'X' or ''
		if button=='Move' or button=='Resize' then
			updateDragOperation()
		elseif button=='Rotate' then
			updateRotateOperation()
		end
	end)
	buttonFillWater.MouseButton1Down:connect(function()
		fillWater = not fillWater
		buttonFillWater.Text = fillWater and 'X' or ''
		if button=='Move' or button=='Resize' then
			updateDragOperation()
		elseif button=='Rotate' then
			updateRotateOperation()
		end
	end)

	function lockInMap()	--Should call this every time the terrain under your selection changes. Don't for resize though, it uses the original lockin for rescaling.
		if selectionStart and selectionEnd then
			local region = Region3.new((selectionStart - Vector3.new(1,1,1)) * resolution, selectionEnd * resolution)
			lockedRegion = region
			lockedMaterials, lockedOccupancies = terrain:ReadVoxels(region, resolution)
		end
	end

	do
		local runService = game:GetService('RunService').RenderStepped
		function quickWait(waitTime)
			if not waitTime then
				runService:wait()
			elseif waitTime < .033333 then
				local startTick = tick()
				runService:wait()
				local delta = tick() - startTick
				if delta <= waitTime * .5 then
					quickWait(waitTime - delta)
				end
			else
				wait(waitTime)
			end
		end
	end

	function clearSelection()
		if selectionArcHandles then
			selectionArcHandles:Destroy()
			selectionArcHandles = nil
		end
		if selectionHandles then
			selectionHandles:Destroy()
			selectionHandles = nil
		end
		if selectionObject then
			selectionObject:Destroy()
			selectionObject = nil
		end
		if selectionPart then
			selectionPart:Destroy()
			selectionPart = nil
		end
	end

	local function round(n)
		return n + .5 - ((n + .5)%1)
	end

	local function positionWorldToVoxel(pos)
		return Vector3.new(ceil(pos.x / resolution), ceil(pos.y / resolution), ceil(pos.z / resolution))
	end

	local function make3DTable(size,fill)
		local size = size or Vector3.new(1,1,1)
		local newTable = {}
		for x = 1, size.x do
			local xt = {}
			for y = 1, size.y do
				local yt = {}
				for z = 1, size.z do
					yt[z] = fill
				end
				xt[y] = yt
			end
			newTable[x] = xt
		end
		return newTable
	end

	local function linInterp(a,b,p)
		return a+(b-a)*p
	end

	local function exaggerate(n,exaggeration)
		return (n-.5)*exaggeration + .5		--optimized
		--return n*exaggeration - exaggeration*.5 + .5
	end
	local function exaggeratedLinInterp(a,b,p,exaggeration)
		local unclamped = (a+(b-a)*p-.5)*exaggeration+.5
		return (unclamped < 0 and 0) or (unclamped > 1 and 1) or unclamped

		--At first I thought this didn't need to be clamped because the terrain clamps that anways.
		--But I then realized I am using this number a bit more before handing it to terrain.
		--After doing some tests. Clamping is necessary for artificial structures being streched. If unclamped, rounding of artificial edges occurs.
		--return (a+(b-a)*p-.5)*exaggeration+.5
		--Maybe this extra dimension of unclamping might be desired for natural terrain, but not artificuial?
	end

	function updateDragOperation()
		local dragVector = dragVector or Vector3.new(0,0,0)
		local temporaryStart = selectionStart
		local temporaryEnd = selectionEnd
		if tool == 'Resize' then
			if dragStart then
				temporaryStart = Vector3.new(
					math.min(
						math.max(temporaryStart.x+dragVector.x,temporaryEnd.x-regionLengthLimit),
						temporaryEnd.x),
					math.min(
						math.max(temporaryStart.y+dragVector.y,temporaryEnd.y-regionLengthLimit),
						temporaryEnd.y),
					math.min(
						math.max(temporaryStart.z+dragVector.z,temporaryEnd.z-regionLengthLimit),
						temporaryEnd.z)
				)
			else
				temporaryEnd = Vector3.new(
					math.max(
						math.min(temporaryEnd.x+dragVector.x,temporaryStart.x+regionLengthLimit),
						temporaryStart.x),
					math.max(
						math.min(temporaryEnd.y+dragVector.y,temporaryStart.y+regionLengthLimit),
						temporaryStart.y),
					math.max(
						math.min(temporaryEnd.z+dragVector.z,temporaryStart.z+regionLengthLimit),
						temporaryStart.z)
				)
			end
			if mode == 'Edit' then
				--[[local loopx = #lockedMaterials		--Tiling resize		--fun but not too many use cases with natural terrain.
				local loopy = #lockedMaterials[1]
				local loopz = #lockedMaterials[1][1]
				local tempRegionSize = Vector3.new(1,1,1) + temporaryEnd - temporaryStart
				local newMat = {}
				local newOcc = {}
				local offsetx = -1
				local offsety = -1
				local offsetz = -1
				if dragStart then
					offsetx = offsetx + (-tempRegionSize.x % loopx)
					offsety = offsety + (-tempRegionSize.y % loopy)
					offsetz = offsetz + (-tempRegionSize.z % loopz)
				end
				for x=1, tempRegionSize.x do
					local targetx = (offsetx + x) % loopx + 1
					local xtm = {}
					local xto = {}
					for y=1, tempRegionSize.y do
						local targety = (offsety + y) % loopy + 1
						local ytm = {}
						local yto = {}
						for z=1, tempRegionSize.z do
							local targetz = (offsetz + z) % loopz + 1
							ytm[z] = lockedMaterials[targetx][targety][targetz]
							yto[z] = lockedOccupancies[targetx][targety][targetz]
						end
						xtm[y] = ytm
						xto[y] = yto
					end
					newMat[x] = xtm
					newOcc[x] = xto
				end]]
		
				--[[local loopx = #lockedMaterials		--Scaling closest neightbor resize --not perfect
				local loopy = #lockedMaterials[1]
				local loopz = #lockedMaterials[1][1]
				local tempRegionSize = Vector3.new(1,1,1) + temporaryEnd - temporaryStart
				local tempSizeX = tempRegionSize.x
				local tempSizeY = tempRegionSize.y
				local tempSizeZ = tempRegionSize.z
				local roundx = tempSizeX < loopx and math.floor or math.ceil
				local roundy = tempSizeY < loopy and math.floor or math.ceil
				local roundz = tempSizeZ < loopz and math.floor or math.ceil
				local newMat = {}
				local newOcc = {}
				for x=1, tempSizeX do
					local targetx = roundx(x/tempSizeX*loopx)
					local xtm = {}
					local xto = {}
					for y=1, tempSizeY do
						local targety = roundy(y/tempSizeY*loopy)
						local ytm = {}
						local yto = {}
						for z=1, tempSizeZ do
							local targetz = roundz(z/tempSizeZ*loopz)
							ytm[z] = lockedMaterials[targetx][targety][targetz]
							yto[z] = lockedOccupancies[targetx][targety][targetz]
						end
						xtm[y] = ytm
						xto[y] = yto
					end
					newMat[x] = xtm
					newOcc[x] = xto
				end]]
		
				local region = Region3.new((temporaryStart - Vector3.new(1,1,1)) * resolution, temporaryEnd * resolution)
				if behindThis then
					terrain:WriteVoxels(behindThis.region, resolution, behindThis.materials, behindThis.occupancies)
				else
					if selectionStart and selectionEnd then
						local region = Region3.new((selectionStart - Vector3.new(1,1,1)) * resolution, selectionEnd * resolution)
						local regionSize = region.Size / resolution
						terrain:WriteVoxels(region, resolution, make3DTable(regionSize,materialAir), make3DTable(regionSize,0))
					end
				end
				behindThis = {}
				behindThis.region = region
				behindThis.materials, behindThis.occupancies = terrain:ReadVoxels(region, resolution)

				local behindMaterials, behindOccupancies = behindThis.materials, behindThis.occupancies

				local loopx = #lockedMaterials - 1
				local loopy = #lockedMaterials[1] - 1
				local loopz = #lockedMaterials[1][1] - 1
				local tempRegionSize = Vector3.new(1,1,1) + temporaryEnd - temporaryStart
				local tempSizeX = tempRegionSize.x
				local tempSizeY = tempRegionSize.y
				local tempSizeZ = tempRegionSize.z
				local newMat = {}
				local newOcc = {}
				for x=1, tempSizeX do
					local scalex = (x-1)/(tempSizeX-1)*loopx
					if scalex ~= scalex then
						scalex = 0
					end
					local startx = floor(scalex)+1
					local endx = startx+1
					local interpScalex = scalex-startx+1
					if startx > loopx then
						endx = startx
					end
		
					local xtm = {}
					local xto = {}
					for y=1, tempSizeY do
						local scaley = (y-1)/(tempSizeY-1)*loopy
						if scaley ~= scaley then
							scaley = 0
						end
						local starty = floor(scaley)+1
						local endy = starty+1
						local interpScaley = scaley-starty+1
						if starty > loopy then
							endy = starty
						end
		
						local ytm = {}
						local yto = {}
						for z=1, tempSizeZ do
							local scalez = (z-1)/(tempSizeZ-1)*loopz	--consider adding 1 here and removing +1's elsewhere
							if scalez ~= scalez then		--undefined check
								scalez = 0
							end
							local startz = floor(scalez)+1
							local endz = startz+1
							local interpScalez = scalez-startz+1
							if startz > loopz then
								endz = startz
							end
		
							local interpz1 = exaggeratedLinInterp(lockedOccupancies[startx][starty][startz],lockedOccupancies[startx][starty][endz],interpScalez, tempSizeZ/(loopz+1))
							local interpz2 = exaggeratedLinInterp(lockedOccupancies[startx][endy][startz],lockedOccupancies[startx][endy][endz],interpScalez, tempSizeZ/(loopz+1))
							local interpz3 = exaggeratedLinInterp(lockedOccupancies[endx][starty][startz],lockedOccupancies[endx][starty][endz],interpScalez, tempSizeZ/(loopz+1))
							local interpz4 = exaggeratedLinInterp(lockedOccupancies[endx][endy][startz],lockedOccupancies[endx][endy][endz],interpScalez, tempSizeZ/(loopz+1))
		
							local interpy1 = exaggeratedLinInterp(interpz1,interpz2,interpScaley, tempSizeY/(loopy+1))
							local interpy2 = exaggeratedLinInterp(interpz3,interpz4,interpScaley, tempSizeY/(loopy+1))
		
							local interpx1 = exaggeratedLinInterp(interpy1,interpy2,interpScalex, tempSizeX/(loopx+1))
		
							local newMaterial = lockedMaterials[round(scalex)+1][round(scaley)+1][round(scalez)+1]
		
							if fillAir and newMaterial == materialAir then
								ytm[z]=behindMaterials[x][y][z]
								yto[z]=behindOccupancies[x][y][z]
							elseif fillWater and newMaterial == materialWater and behindMaterials[x][y][z] ~= materialAir then
								ytm[z]=behindMaterials[x][y][z]
								yto[z]=behindOccupancies[x][y][z]
							else
								ytm[z]=newMaterial
								yto[z]=interpx1
							end
						end
						xtm[y] = ytm
						xto[y] = yto
					end
					newMat[x] = xtm
					newOcc[x] = xto
				end
		
				terrain:WriteVoxels(region, resolution, newMat, newOcc)
			else
				behindThis = nil
			end
		elseif tool == 'Move' then
			temporaryStart = temporaryStart + dragVector
			temporaryEnd = temporaryEnd + dragVector
			if mode == 'Edit' then
				local region = Region3.new((temporaryStart - Vector3.new(1,1,1)) * resolution, temporaryEnd * resolution)
				if behindThis then
					terrain:WriteVoxels(behindThis.region, resolution, behindThis.materials, behindThis.occupancies)
				else
					if selectionStart and selectionEnd then
						local region = Region3.new((selectionStart - Vector3.new(1,1,1)) * resolution, selectionEnd * resolution)
						local regionSize = region.Size / resolution
						terrain:WriteVoxels(region, resolution, make3DTable(regionSize,materialAir), make3DTable(regionSize,0))
					end
				end
				behindThis = {}
				behindThis.region = region
				behindThis.materials, behindThis.occupancies = terrain:ReadVoxels(region, resolution)

				local behindMaterials, behindOccupancies = behindThis.materials, behindThis.occupancies
		
				if not (fillAir or fillWater) then
					terrain:WriteVoxels(region, resolution, lockedMaterials, lockedOccupancies)
				else
					local newMat = {}
					local newOcc = {}
		
					for x,xv in ipairs(lockedMaterials) do
						local xtm = {}
						local xto = {}
						for y,yv in ipairs(xv) do
							local ytm = {}
							local yto = {}
							for z,zv in ipairs(yv) do
								if fillAir and zv == materialAir then
									ytm[z]=behindMaterials[x][y][z]
									yto[z]=behindOccupancies[x][y][z]
								elseif fillWater and zv == materialWater and behindMaterials[x][y][z] ~= materialAir then
									ytm[z]=behindMaterials[x][y][z]
									yto[z]=behindOccupancies[x][y][z]
								else
									ytm[z]=lockedMaterials[x][y][z]
									yto[z]=lockedOccupancies[x][y][z]
								end
							end
							xtm[y] = ytm
							xto[y] = yto
						end
						newMat[x] = xtm
						newOcc[x] = xto
					end
					terrain:WriteVoxels(region, resolution, newMat, newOcc)
				end
			end
		end
		renderSelection(temporaryStart,temporaryEnd)
	end

	function dragHandles(face, delta)
		local normal = faceToNormal[face]
		local delta = delta
		local newDragVector = normal * floor((delta + .5) / resolution)
		dragStart = normal.x < 0 or normal.y < 0 or normal.z < 0	--This determines if we are dragging a side on the min or max bounds
		if newDragVector ~= dragVector then
			dragVector = newDragVector
			updateDragOperation()
		end
	end

	local function rotate(mx,x,my,y,rotation)
		if rotation == 1 then
			return my + 1 - y, x 
		elseif rotation == 2 then
			return mx + 1 - x, my + 1 - y
		elseif rotation == 3 then
			return y, mx + 1 - x
		end
		return x,y
	end

	function updateRotateOperation()
		local dragAngle = dragAngle or 0
		local rotationCFrame = CFrame.Angles(
			axis ~= 'X' and 0 or dragAngle * rotationInterval,
			axis ~= 'Y' and 0 or dragAngle * rotationInterval,
			axis ~= 'Z' and 0 or dragAngle * rotationInterval
		)
		local temporarySize = Vector3.new(1,1,1) + selectionEnd - selectionStart
		local centerOffset = Vector3.new(ceil(temporarySize.x * .5), ceil(temporarySize.y * .5), ceil(temporarySize.z * .5))

		temporarySize = rotationCFrame * temporarySize
		local temporarySizeX = round(math.abs(temporarySize.x))	--I need to round these because of floating point imprecision
		local temporarySizeY = round(math.abs(temporarySize.y))
		local temporarySizeZ = round(math.abs(temporarySize.z))
		centerOffset = centerOffset - Vector3.new(ceil(temporarySizeX * .5), ceil(temporarySizeY * .5), ceil(temporarySizeZ * .5))

		local temporaryEnd = selectionStart + centerOffset + Vector3.new(temporarySizeX, temporarySizeY, temporarySizeZ) - Vector3.new(1, 1, 1)
		local temporaryStart = selectionStart + centerOffset

		if mode == 'Edit' then
		local region = Region3.new((temporaryStart - Vector3.new(1,1,1)) * resolution, temporaryEnd * resolution)
			if behindThis then
				terrain:WriteVoxels(behindThis.region, resolution, behindThis.materials, behindThis.occupancies)
			else
				if selectionStart and selectionEnd then
					local region = Region3.new((selectionStart - Vector3.new(1,1,1)) * resolution, selectionEnd * resolution)
					local regionSize = region.Size / resolution
					terrain:WriteVoxels(region, resolution, make3DTable(regionSize,materialAir), make3DTable(regionSize,0))
				end
				--local regionSize = lockedRegion.Size / resolution
				--terrain:WriteVoxels(lockedRegion, resolution, make3DTable(regionSize,materialAir), make3DTable(regionSize,0))
			end
			behindThis = {}
			behindThis.region = region
			behindThis.materials, behindThis.occupancies = terrain:ReadVoxels(region, resolution)

			local newMat = {}
			local newOcc = {}

			for x=1, temporarySizeX do
				local xtm = {}
				local xto = {}
				for y=1, temporarySizeY do
					local ytm = {}
					local yto = {}
					for z=1, temporarySizeZ do
						local targetx = x
						local targety = y
						local targetz = z
						if axis == 'Y' then	--prioritize y because I know this is the primary rotation axis
							targetx, targetz = rotate(temporarySizeX, x, temporarySizeZ, z, dragAngle)
						elseif axis == 'X' then
							targetz, targety = rotate(temporarySizeZ, z, temporarySizeY, y, dragAngle)
						elseif axis == 'Z' then
							targety, targetx = rotate(temporarySizeY, y, temporarySizeX, x, dragAngle)
						end
						local newMaterial = lockedMaterials[targetx][targety][targetz]

						if fillAir and newMaterial == materialAir then
							ytm[z]=behindThis.materials[x][y][z]
							yto[z]=behindThis.occupancies[x][y][z]
						elseif fillWater and newMaterial == materialWater and behindThis.materials[x][y][z] ~= materialAir then
							ytm[z]=behindThis.materials[x][y][z]
							yto[z]=behindThis.occupancies[x][y][z]
						else
							ytm[z]=newMaterial
							yto[z]=lockedOccupancies[targetx][targety][targetz]
						end
					end
					xtm[y] = ytm
					xto[y] = yto
				end
				newMat[x] = xtm
				newOcc[x] = xto
			end

			terrain:WriteVoxels(region, resolution, newMat, newOcc)
		end
		renderSelection(temporaryStart,temporaryEnd,rotationCFrame)
	end

	function dragArcHandles(rotationAxis,relativeAngle,deltaRadius)
		axis = rotationAxis.Name
		local newDragAngle = round(relativeAngle / rotationInterval) % 4
		if newDragAngle ~= dragAngle then
			dragAngle = newDragAngle
			updateRotateOperation()
		end
	end

	buttonCopy.MouseButton1Down:connect(function()
		if selectionStart and selectionEnd then
			local selectionStartInt16=Vector3int16.new(selectionStart.x-1,selectionStart.y-1,selectionStart.z-1)
			local selectionEndInt16=Vector3int16.new(selectionEnd.x-1,selectionEnd.y-1,selectionEnd.z-1)
			local region = Region3int16.new(selectionStartInt16,selectionEndInt16)
			copyRegion = terrain:CopyRegion(region)
			selectionEffect(nil,nil,'New Yeller',1,1.2,.5)
		end
	end)

	buttonPaste.MouseButton1Down:connect(function()
		if copyRegion then
			selectionEnd=selectionStart+copyRegion.SizeInCells-Vector3.new(1,1,1)

			local region = Region3.new((selectionStart - Vector3.new(1,1,1)) * resolution, selectionEnd * resolution)
			behindThis = {}
			behindThis.region = region
			behindThis.materials, behindThis.occupancies = terrain:ReadVoxels(region, resolution)

			terrain:PasteRegion(copyRegion,Vector3int16.new(selectionStart.x-1,selectionStart.y-1,selectionStart.z-1),true)
			setButton('Move')
			changeHistory:SetWaypoint('Terrain Paste')
			selectionEffect(nil,nil,'Lime green',1.2,1,.5)
		end
	end)

	buttonDelete.MouseButton1Down:connect(function()
		if selectionStart and selectionEnd then
			local region = Region3.new((selectionStart - Vector3.new(1,1,1)) * resolution, selectionEnd * resolution)
			local regionSize = region.Size / resolution
			local emptyMaterialMap = make3DTable(regionSize,materialAir)
			local emptyOccupancyMap = make3DTable(regionSize,0)

			--[[behindThis = {}
			behindThis.region = region
			behindThis.materials, behindThis.occupancies = emptyMaterialMap, emptyOccupancyMap

			terrain:WriteVoxels(region, resolution, emptyMaterialMap, emptyOccupancyMap)]]
			if behindThis then
				terrain:WriteVoxels(behindThis.region, resolution, behindThis.materials, behindThis.occupancies)
			else
				if selectionStart and selectionEnd then
					terrain:WriteVoxels(region, resolution, emptyMaterialMap, emptyOccupancyMap)
				end
			end
			behindThis = {}
			behindThis.region = region
			behindThis.materials, behindThis.occupancies = terrain:ReadVoxels(region, resolution)

			--[[lockedRegion = region
			lockedMaterials, lockedOccupancies = emptyMaterialMap, emptyOccupancyMap]]
			local oldStart, oldEnd = selectionStart, selectionEnd
			selectionStart, selectionEnd = nil, nil
			setButton('Select')

			changeHistory:SetWaypoint('Terrain Delete')
			selectionEffect(oldStart,oldEnd,'Really red',1,1.2,.5)
		end
	end)

	function selectionEffect(temporaryStart,temporaryEnd,color,sizeFrom,sizeTo,effectTime)
		local temporaryStart = temporaryStart or selectionStart
		local temporaryEnd = temporaryEnd or selectionEnd

		local effectPart = Instance.new('Part')
		effectPart.Name = 'EffectPart'
		effectPart.Transparency = 1
		effectPart.TopSurface = 'Smooth'
		effectPart.BottomSurface = 'Smooth'
		effectPart.Anchored = true
		effectPart.CanCollide = false
		effectPart.formFactor = 'Custom'
		effectPart.Parent = gui

		local selectionEffectObject = Instance.new('SelectionBox')
		selectionEffectObject.Name = 'SelectionObject'
		selectionEffectObject.Transparency = 1
		selectionEffectObject.SurfaceTransparency = .75
		selectionEffectObject.SurfaceColor = BrickColor.new(color)
		selectionEffectObject.Adornee = effectPart
		selectionEffectObject.Parent = effectPart

		local baseSize = ((temporaryEnd - temporaryStart + Vector3.new(1,1,1)) * resolution + Vector3.new(.21,.21,.21))
		effectPart.CFrame = CFrame.new((temporaryStart + temporaryEnd - Vector3.new(1, 1, 1)) * .5 * resolution)
		effectPart.Size = baseSize * sizeFrom
		local endTick=tick()+effectTime
		while endTick>tick() do
			local percent=1-(endTick-tick())/effectTime
			selectionEffectObject.SurfaceTransparency = .75 + percent*.25
			effectPart.Size = baseSize * (sizeFrom+(sizeTo-sizeFrom)*percent)
			wait()
		end
		effectPart:Destroy()
	end

	function renderSelection(temporaryStart,temporaryEnd,rotation)
		local temporaryStart = temporaryStart or selectionStart
		local temporaryEnd = temporaryEnd or selectionEnd
		local seeable = false
		if temporaryStart and temporaryEnd and selectionPart then
			seeable = true
			local temporarySize = ((temporaryEnd - temporaryStart + Vector3.new(1,1,1)) * resolution + Vector3.new(.2,.2,.2))
			if rotation then
				local rotatedSize = rotation * temporarySize
				temporarySize = Vector3.new(math.abs(rotatedSize.x), math.abs(rotatedSize.y), math.abs(rotatedSize.z))
			end
			selectionPart.Size = temporarySize
			selectionPart.CFrame = CFrame.new((temporaryStart + temporaryEnd - Vector3.new(1, 1, 1)) * .5 * resolution) * (rotation or CFrame.new(0,0,0))
		end
		if selectionObject then
			selectionObject.Visible = seeable
			selectionObject.Color = BrickColor.new(mode == 'Select' and 'Toothpaste' or editColor1)
			selectionObject.SurfaceColor = BrickColor.new(mode == 'Select' and 'Toothpaste' or editColor1)
		end
		if selectionHandles then
			selectionHandles.Visible = seeable and (tool == 'Move' or tool == 'Resize')
			selectionHandles.Color = BrickColor.new(mode == 'Select' and 'Cyan' or editColor2)
			selectionHandles.Style = tool == 'Move' and Enum.HandlesStyle.Movement or Enum.HandlesStyle.Resize
		end
		if selectionArcHandles then
			selectionArcHandles.Visible = seeable and tool == 'Rotate'
			selectionArcHandles.Color = BrickColor.new(mode == 'Select' and 'Cyan' or editColor2)
		end
	end
	
	function Selected()
		--plugin:Activate(true)
		--regionEditButton:SetActive(true)
		on = true
		gui.Parent = coreGui

		if not selectionPart then
			selectionPart = Instance.new('Part')
			selectionPart.Name = 'SelectionPart'
			selectionPart.Transparency = 1
			selectionPart.TopSurface = 'Smooth'
			selectionPart.BottomSurface = 'Smooth'
			selectionPart.Anchored = true
			selectionPart.CanCollide = false
			selectionPart.formFactor = 'Custom'
			selectionPart.Parent = gui
		end
		if not selectionObject then
			selectionObject = Instance.new('SelectionBox')
			selectionObject.Name = 'SelectionObject'
			selectionObject.Color = BrickColor.new(mode == 'Select' and 'Toothpaste' or editColor1)
			selectionObject.SurfaceTransparency = .85
			selectionObject.SurfaceColor = BrickColor.new(mode == 'Select' and 'Toothpaste' or editColor1)
			selectionObject.Adornee = selectionPart
			selectionObject.Visible = false
			selectionObject.Parent = selectionPart
		end
		if not selectionHandles then
			selectionHandles = Instance.new('Handles')
			selectionHandles.Name = 'SelectionHandles'
			selectionHandles.Color = BrickColor.new(mode == 'Select' and 'Toothpaste' or editColor2)
			selectionHandles.Adornee = selectionPart
			selectionHandles.Visible = false
			selectionHandles.Parent = coreGui--game.Workspace--guiFrame--selectionPart
			selectionHandles.MouseDrag:connect(dragHandles)
		end
		if not selectionArcHandles then
			selectionArcHandles = Instance.new('ArcHandles')
			selectionArcHandles.Name = 'SelectionArcHandles'
			selectionArcHandles.Color = BrickColor.new(mode == 'Select' and 'Toothpaste' or editColor2)
			selectionArcHandles.Adornee = selectionPart
			selectionArcHandles.Visible = false
			selectionArcHandles.Parent = coreGui--game.Workspace--guiFrame--selectionPart
			selectionArcHandles.MouseDrag:connect(dragArcHandles)
		end
		renderSelection()
		setButton(button)
	end
	
	function Deselected()
		setButton('Select')
		gui.Parent = script.Parent
		clearSelection()
		--regionEditButton:SetActive(false)
		behindThis = nil
		on = false
		if turnOff then
			turnOff()
		end
	end

	mouse.Button1Down:connect(function()
		if on and mode == 'Select' then
			mouseDown = true
			behindThis = nil
			local mousePos = mouse.Hit.p + mouse.UnitRay.Direction * .05
			if mouse.Target == nil then	--cage the cursor so that it does not fly away
				mousePos = game.Workspace.CurrentCamera.CoordinateFrame.p + mouse.UnitRay.Direction * 1000
			end
			clickStart = positionWorldToVoxel(mousePos)
			local thisDownLoop = {}
			downLoop = thisDownLoop
			while thisDownLoop == downLoop and mouseDown and on and mode == 'Select' do
				local mousePos = mouse.Hit.p + mouse.UnitRay.Direction * .05
				if mouse.Target == nil then	--cage the cursor so that it does not fly away
					mousePos = game.Workspace.CurrentCamera.CoordinateFrame.p + mouse.UnitRay.Direction * 1000
				end
				local voxelCurrent = positionWorldToVoxel(mousePos)
				voxelCurrent = Vector3.new(
					math.max(math.min(voxelCurrent.x,clickStart.x+regionLengthLimit),clickStart.x-regionLengthLimit),
					math.max(math.min(voxelCurrent.y,clickStart.y+regionLengthLimit),clickStart.y-regionLengthLimit),
					math.max(math.min(voxelCurrent.z,clickStart.z+regionLengthLimit),clickStart.z-regionLengthLimit))
				selectionStart = Vector3.new(math.min(clickStart.x, voxelCurrent.x), math.min(clickStart.y, voxelCurrent.y), math.min(clickStart.z, voxelCurrent.z))
				selectionEnd = Vector3.new(math.max(clickStart.x, voxelCurrent.x), math.max(clickStart.y, voxelCurrent.y), math.max(clickStart.z, voxelCurrent.z))
				renderSelection()
				quickWait()
			end
		end
	end)
	mouse.Button1Up:connect(function()
		mouseDown = false
		if dragVector and dragVector.magnitude > 0 then
			if tool == 'Resize' then
				--[[if dragStart then
					selectionStart = Vector3.new(math.min(selectionStart.x+dragVector.x,selectionEnd.x),math.min(selectionStart.y+dragVector.y,selectionEnd.y),math.min(selectionStart.z+dragVector.z,selectionEnd.z))
				else
					selectionEnd = Vector3.new(math.max(selectionEnd.x+dragVector.x,selectionStart.x),math.max(selectionEnd.y+dragVector.y,selectionStart.y),math.max(selectionEnd.z+dragVector.z,selectionStart.z))
				end]]
				if dragStart then
					selectionStart = Vector3.new(
						math.min(
							math.max(selectionStart.x+dragVector.x,selectionEnd.x-regionLengthLimit),
							selectionEnd.x),
						math.min(
							math.max(selectionStart.y+dragVector.y,selectionEnd.y-regionLengthLimit),
							selectionEnd.y),
						math.min(
							math.max(selectionStart.z+dragVector.z,selectionEnd.z-regionLengthLimit),
							selectionEnd.z)
					)
				else
					selectionEnd = Vector3.new(
						math.max(
							math.min(selectionEnd.x+dragVector.x,selectionStart.x+regionLengthLimit),
							selectionStart.x),
						math.max(
							math.min(selectionEnd.y+dragVector.y,selectionStart.y+regionLengthLimit),
							selectionStart.y),
						math.max(
							math.min(selectionEnd.z+dragVector.z,selectionStart.z+regionLengthLimit),
							selectionStart.z)
					)
				end
			elseif tool == 'Move' then
				selectionStart = selectionStart + dragVector
				selectionEnd = selectionEnd + dragVector
			end
			changeHistory:SetWaypoint('Terrain '..button)
		end
		if dragAngle and dragAngle ~= 0 then
			local rotationCFrame = CFrame.Angles(
				axis ~= 'X' and 0 or dragAngle * rotationInterval,
				axis ~= 'Y' and 0 or dragAngle * rotationInterval,
				axis ~= 'Z' and 0 or dragAngle * rotationInterval
			)
			local temporarySize = Vector3.new(1,1,1) + selectionEnd - selectionStart
			local centerOffset = Vector3.new(ceil(temporarySize.x * .5), ceil(temporarySize.y * .5), ceil(temporarySize.z * .5))
			temporarySize = rotationCFrame * temporarySize
			local temporarySizeX = round(math.abs(temporarySize.x))	--I need to round these because of floating point imprecision
			local temporarySizeY = round(math.abs(temporarySize.y))
			local temporarySizeZ = round(math.abs(temporarySize.z))
			centerOffset = centerOffset - Vector3.new(ceil(temporarySizeX * .5), ceil(temporarySizeY * .5), ceil(temporarySizeZ * .5))
			
			selectionEnd = selectionStart + centerOffset + Vector3.new(temporarySizeX, temporarySizeY, temporarySizeZ) - Vector3.new(1, 1, 1)
			selectionStart = selectionStart + centerOffset
			lockInMap()
			changeHistory:SetWaypoint('Terrain '..button)
		end

		dragVector = nil
		dragAngle = nil
		renderSelection()
		--lockInMap()
	end)

	closeButton.MouseButton1Down:connect(Deselected)

	--[[plugin.Deactivation:connect(function()
		if on then
			Deselected()
		end
	end)]]

	local function historyChanged()
		selectionStart = nil
		selectionEnd = nil
		lockedMaterials = nil
		lockedOccupancies = nil
		setButton('Select')
	end

	changeHistory.OnUndo:connect(historyChanged)
	changeHistory.OnRedo:connect(historyChanged)

end

function On(mouseHandMeDown,turnOffHandMeDown)
	mouse = mouseHandMeDown
	turnOff = turnOffHandMeDown
	if not setup then	--I do this so that things only get set up when this plugin is used.
		FirstTimeSetUp()
	end
	Selected()
end

function Off()
	if Deselected then
		Deselected()
	end
end

return {
	['On'] = On,
	['Off'] = Off,
}


]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="ScreenGui" referent="RBX885A7E913AB24E5F8C7BC5DAFA2672C2">
			<Properties>
				<string name="Name">TerrainRegionGui</string>
			</Properties>
			<Item class="Frame" referent="RBX3430E1F14B0E41BC9F8D7D8E835CAA4E">
				<Properties>
					<bool name="Active">true</bool>
					<Color3 name="BackgroundColor3">4294967295</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">Frame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>180</XO>
						<YS>0</YS>
						<YO>340</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">6</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextButton" referent="RBXC748E795BE774210B60DCB3A992AFFC9">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<bool name="Modal">false</bool>
						<string name="Name">ButtonSelect</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>35</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>-20</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">5</token>
						<string name="Text">Select</string>
						<Color3 name="TextColor3">4282946004</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX1758C157AE514A9BB5DA30D831E8ACF7">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<bool name="Modal">false</bool>
						<string name="Name">ButtonRotate</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>125</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>-20</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">4</token>
						<string name="Text">Rotate</string>
						<Color3 name="TextColor3">4293848814</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX27DDE9D364B94AFF8AB224CB3C323588">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<bool name="Modal">false</bool>
						<string name="Name">ButtonResize</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>95</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>-20</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">4</token>
						<string name="Text">Resize</string>
						<Color3 name="TextColor3">4293848814</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX66A7CFDD08F6458B834B3D2B11FFB15E">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0.600000024</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<string name="Name">Divider2</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>165</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>2</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBXE4B9E8676A4141FB9A18101E338DFCEB">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<bool name="Modal">false</bool>
						<string name="Name">ButtonCopy</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>175</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>-20</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">4</token>
						<string name="Text">Copy</string>
						<Color3 name="TextColor3">4293848814</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX36BAF06F5DE54CC4A98BFE317C20DE81">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<bool name="Modal">false</bool>
						<string name="Name">ButtonPaste</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>205</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>-20</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">4</token>
						<string name="Text">Paste</string>
						<Color3 name="TextColor3">4293848814</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBXCB54246B30A047CEA603C5756847826D">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<bool name="Modal">false</bool>
						<string name="Name">ButtonFillAir</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>285</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>30</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">4</token>
						<string name="Text">X</string>
						<Color3 name="TextColor3">4293848814</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
					<Item class="TextLabel" referent="RBXB2368B59B618485983D40805A3E4A69B">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294967295</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">6</token>
							<string name="Name">Label</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>30</XO>
								<YS>0.5</YS>
								<YO>-10</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>90</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Merge Empty</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextLabel" referent="RBXE0F32D2168CF41A5AAAB58BD57A7559E">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0.600000024</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<string name="Name">Divider3</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>275</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>2</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX6C1FFBB060824A89A8EA9D2CE0447033">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<bool name="Modal">false</bool>
						<string name="Name">ButtonFillWater</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>315</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>30</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">4</token>
						<string name="Text">X</string>
						<Color3 name="TextColor3">4293848814</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">2</int>
					</Properties>
					<Item class="TextLabel" referent="RBX8FB882D6B9114D3C91F400D2E9BC47F6">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294967295</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">6</token>
							<string name="Name">Label</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>30</XO>
								<YS>0.5</YS>
								<YO>-10</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>90</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Fill  Water</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX5B52F714092B484C88F4890829CA7BB8">
					<Properties>
						<bool name="Active">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">DoubleBacking</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>-7</XO>
							<YS>0</YS>
							<YO>-7</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>16</XO>
							<YS>1</YS>
							<YO>16</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">6</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBXE011A63F1F5E45E6AFD7321D90071826">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<bool name="Modal">false</bool>
						<string name="Name">ButtonMove</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>65</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>-20</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">4</token>
						<string name="Text">Move</string>
						<Color3 name="TextColor3">4293848814</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX5D06B5D81D444E5F9E52348E82A6BA05">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<bool name="Modal">false</bool>
						<string name="Name">ButtonDelete</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>235</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>-20</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">4</token>
						<string name="Text">Delete</string>
						<Color3 name="TextColor3">4293848814</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBXEE73A893C581407E88F904AA3E82A990">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0.75</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<string name="Name">TitleLabel</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>25</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Regions</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBXCB17CA7B062F4CAC97FF2000B327D6EE">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">4</token>
						<bool name="Modal">false</bool>
						<string name="Name">CloseButton</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-26</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>25</XO>
							<YS>0</YS>
							<YO>25</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text">X</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX59E0E837CDC94D0FB8D40763ECA22D99">
			<Properties>
				<string name="Name">TerrainGenerationGui</string>
			</Properties>
			<Item class="Frame" referent="RBX85718357ED9643C6959BA47AE06B7A0C">
				<Properties>
					<bool name="Active">true</bool>
					<Color3 name="BackgroundColor3">4294967295</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">Frame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>200</XO>
						<YS>0</YS>
						<YO>400</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">6</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextButton" referent="RBXAABF337BC16B4433BCE4E8957DF224DD">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<bool name="Modal">false</bool>
						<string name="Name">ClearButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>1</YS>
							<YO>-35</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>-20</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">4</token>
						<string name="Text">Clear</string>
						<Color3 name="TextColor3">4293848814</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBXA1ABBC274BC644EE8FDD29EDE02A557F">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0.600000024</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<string name="Name">Divider</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>-80</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>2</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX240E2CFD87F14BC786ABC229E96E8D3B">
					<Properties>
						<bool name="Active">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">DoubleBacking</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>-7</XO>
							<YS>0</YS>
							<YO>-7</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>16</XO>
							<YS>1</YS>
							<YO>16</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">6</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBXD0EEFAB61CD842CCA432446EF2ABABE5">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0.75</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<string name="Name">TitleLabel</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>25</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Generation</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBXB62D0174A36C4ECA9756AB1AF8089ED3">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">4</token>
						<bool name="Modal">false</bool>
						<string name="Name">CloseButton</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-26</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>25</XO>
							<YS>0</YS>
							<YO>25</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text">X</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="ScrollingFrame" referent="RBXD902E20250474606AE0A630DE6358551">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<Content name="BottomImage"><url>rbxasset://textures/ui/studs.png</url></Content>
						<Vector2 name="CanvasPosition">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<UDim2 name="CanvasSize">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>780</YO>
						</UDim2>
						<bool name="ClipsDescendants">true</bool>
						<bool name="Draggable">false</bool>
						<Content name="MidImage"><url>rbxasset://textures/ui/smooth.png</url></Content>
						<string name="Name">ScrollingFrame</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<int name="ScrollBarThickness">12</int>
						<bool name="ScrollingEnabled">true</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>-115</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Content name="TopImage"><url>rbxasset://textures/ui/studs.png</url></Content>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
					<Item class="Frame" referent="RBXB4066FCEDABE47ECB582047119E695F8">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294967295</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">Canvas</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-13</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX6A84DE695B7C4268B828574F6C417AC5">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<bool name="Modal">false</bool>
						<string name="Name">GenerateButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>1</YS>
							<YO>-70</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>-20</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">4</token>
						<string name="Text">Generate</string>
						<Color3 name="TextColor3">4293848814</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX71209F44E1CE40D6B70D3263E583F321">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4278190080</Color3>
						<float name="BackgroundTransparency">0.699999988</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">ScrollBackground</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-12</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>12</XO>
							<YS>1</YS>
							<YO>-115</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="TextButton" referent="RBX6D99DF2A3ECF4FE68DA0C597F0301541">
				<Properties>
					<bool name="Active">true</bool>
					<bool name="AutoButtonColor">true</bool>
					<Color3 name="BackgroundColor3">4294967295</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<token name="Font">4</token>
					<token name="FontSize">6</token>
					<bool name="Modal">false</bool>
					<string name="Name">TemplateCheckBox</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>5</XO>
						<YS>1</YS>
						<YO>-36</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selected">false</bool>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>26</XO>
						<YS>0</YS>
						<YO>26</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">4</token>
					<string name="Text">X</string>
					<Color3 name="TextColor3">4293848814</Color3>
					<bool name="TextScaled">false</bool>
					<Color3 name="TextStrokeColor3">4278190080</Color3>
					<float name="TextStrokeTransparency">1</float>
					<float name="TextTransparency">0</float>
					<bool name="TextWrapped">false</bool>
					<token name="TextXAlignment">2</token>
					<token name="TextYAlignment">1</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">2</int>
				</Properties>
				<Item class="TextLabel" referent="RBX8E6F64245CF749EFBA2FB4812C4CC028">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">5</token>
						<string name="Name">Label</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>20</XO>
							<YS>0.5</YS>
							<YO>-10</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>90</XO>
							<YS>0</YS>
							<YO>20</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">snowcap mountains</string>
						<Color3 name="TextColor3">4294111986</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">0</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
			</Item>
			<Item class="TextButton" referent="RBXCBA4FA1988674067A34DFA564D06E511">
				<Properties>
					<bool name="Active">true</bool>
					<bool name="AutoButtonColor">false</bool>
					<Color3 name="BackgroundColor3">4294967295</Color3>
					<float name="BackgroundTransparency">0.75</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<token name="Font">4</token>
					<token name="FontSize">6</token>
					<bool name="Modal">false</bool>
					<string name="Name">TemplateSection</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selected">false</bool>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>20</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<string name="Text">Section</string>
					<Color3 name="TextColor3">4294967295</Color3>
					<bool name="TextScaled">false</bool>
					<Color3 name="TextStrokeColor3">4278190080</Color3>
					<float name="TextStrokeTransparency">1</float>
					<float name="TextTransparency">0</float>
					<bool name="TextWrapped">false</bool>
					<token name="TextXAlignment">2</token>
					<token name="TextYAlignment">1</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX76F9979530114D04A1F8B0453CE17AF7">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">0.899999976</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Frame</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>70</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>
